<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>Vitte Light — Guide utilisateur</title>
    <link rel="stylesheet" href="./css/style.css" />

    <link rel="sitemap" type="application/xml" title="Sitemap"
        href="https://vitte-lang.github.io/VitteLight/sitemap.xml">
    <link rel="alternate" type="text/plain" title="Robots" href="https://vitte-lang.github.io/VitteLight/robots.txt">
    <meta name="robots" content="index, follow">
</head>

<body>

    <a class="skip" href="#content">Aller au contenu</a>

    <!-- ===== Toolbar ===== -->
    <div class="toolbar">
        <div class="wrap container">
            <span class="brand">Vitte Light — Guide</span>

            <div class="srch" role="combobox" aria-expanded="false" aria-owns="suggestions">
                <input id="q" type="search" placeholder="Rechercher (Ctrl+K)" autocomplete="off"
                    aria-label="Rechercher" />
                <button id="searchBtn" class="btn" type="button" aria-label="Lancer la recherche">Rechercher</button>
                <div id="suggestions" class="sugg" hidden></div>
            </div>

            <span class="split" aria-hidden="true"></span>
            <span id="hits" class="mini">Prêt</span>

            <button id="zoomOut" class="btn" type="button" aria-label="Diminuer">A−</button>
            <button id="zoomIn" class="btn" type="button" aria-label="Augmenter">A+</button>
            <button id="modeBtn" class="btn" type="button" aria-pressed="false">Thème: Auto</button>
            <button id="printBtn" class="btn" type="button">Imprimer</button>
        </div>
    </div>

    <!-- ===== Header ===== -->
    <header class="container" style="padding:16px 0">
        <h1 id="intro">VITTE LIGHT — Guide utilisateur complet</h1>
        <p class="mini">Révision courante</p>
    </header>

    <!-- ===== Main ===== -->
    <main id="main" class="container">
        <!-- Sommaire -->
        <nav id="sommaire" class="toc" aria-label="Sommaire">
            <strong>Sommaire</strong>
            <ul>
                
                <li><a href="#intro">Introduction</a></li>

                <li><a href="#structure">Structure de projet</a></li>
                <li><a href="#cli">Outils en ligne de commande</a></li>
                <li><a href="#syntaxe">Syntaxe : découverte progressive</a></li>
                <li><a href="#exemples">Premiers exemples</a></li>
                <li><a href="#memoire">Mémoire et sécurité</a></li>
                <li><a href="#erreurs">Gestion des erreurs</a></li>
                <li><a href="#ffi">Interopérabilité C (FFI)</a></li>
                <li><a href="#stdlib">Stdlib — aperçu</a></li>
                <li><a href="#style">Style et bonnes pratiques</a></li>
                <li><a href="#niveaux">Conseils par niveau</a></li>
                <li><a href="#limites">Limites (version Light)</a></li>
                <li><a href="#codes-sortie">Codes Sorie</a></li>
                <li><a href="#diagnostics">Diagnostic</a></li>
                <li><a href="#checklist">Checklist</a></li>
            </ul>
        </nav>


    </main>

    <!-- FAB Sommaire -->
    <button id="fabToc" class="fab" type="button" hidden>Sommaire</button>

    <!-- 0) INTRO -->
    <section id="intro">
        <h2>0) Introduction — VITTE LIGHT</h2>

        <div class="callout info">
            <h4>En clair</h4>
            <ul>
                <li><strong>Vitte Light</strong> (VITL) est un langage simple et moderne pour écrire des petits
                    programmes
                    <em>rapides</em> et <em>sûrs</em>.
                </li>
                <li>Deux usages : <strong>exécuter</strong> un fichier immédiatement (VM) ou <strong>compiler</strong>
                    un
                    binaire autonome ultra-léger.</li>
                <li>Pas de GC lourd ni de <em>malloc/free</em> à la main : mémoire gérée par <strong>références
                        comptées</strong> (<code>Rc</code>/<code>Weak</code>).</li>
                <li>Fonctionne tel quel sur Linux, macOS et Windows ; outil unique, options claires.</li>
            </ul>
        </div>

        <p>
            <strong>Vitte Light</strong> (abrégé <strong>VITL</strong>) est une déclinaison minimaliste du langage
            Vitte.
            L’objectif : offrir une
            <em>syntaxe cohérente</em>, des <em>outils intégrés</em> (formatage, analyse statique, tests, génération de
            doc)
            et un modèle mémoire
            <em>prévisible</em>, afin que débutants, développeurs intermédiaires et professionnels soient vite
            productifs —
            que ce soit pour
            un script d’atelier, un petit binaire livré à un client, ou un module embarqué via FFI dans une base C
            existante.
        </p>

        <!-- 0.1 -->
        <section id="philosophie">
            <h3>0.1 Philosophie du langage</h3>
            <div class="grid-2">
                <ul>
                    <li><strong>Minimalisme utile</strong> : peu de concepts, bien polis (immutabilité par défaut,
                        <code>Result</code>, <code>match</code> exhaustif).
                    </li>
                    <li><strong>Cohérence</strong> : même logique partout (noms, modules, erreurs explicites,
                        conversions
                        intentionnelles).</li>
                    <li><strong>Polyvalence</strong> : itération rapide via VM ; livraison stable via compilation
                        native.</li>
                    <li><strong>Sécurité pragmatique</strong> : pas d’<code>unsafe</code> hors FFI, contrôle des bornes,
                        messages d’erreurs guidants.</li>
                    <li><strong>Portabilité</strong> : mêmes commandes, mêmes sources, mêmes résultats sur les OS
                        majeurs.</li>
                </ul>
                <div class="callout ok">
                    <h4>Pourquoi ce choix&nbsp;?</h4>
                    <p>
                        La majorité des tâches quotidiennes (scripts, outils CLI, glue entre systèmes) ne nécessitent ni
                        threads
                        lourds ni runtime sophistiqué.
                        VITL couvre les “80&nbsp;%” de besoins fréquents, sans la complexité d’un écosystème massif.
                    </p>
                    <p class="note">
                        Quand il faut “sortir du cadre” (concurrence native, libs spécialisées, frameworks complets), on
                        isole la
                        partie critique en externe (C, etc.) et on relie via FFI.
                    </p>
                </div>
            </div>

            <div class="card">
                <strong>Ce que VITL n’est pas</strong>
                <ul>
                    <li>Un langage à <em>runtime lourd</em> : pas de GC complet, pas de VM omniprésente en production si
                        vous
                        compilez en natif.</li>
                    <li>Un framework web clé en main : vous pouvez écrire des serveurs, mais VITL privilégie les outils
                        et
                        binaires simples.</li>
                    <li>Un substitut aux écosystèmes “batteries incluses” massifs : utilisez le FFI pour tirer parti
                        d’une lib
                        existante si nécessaire.</li>
                </ul>
            </div>
        </section>

        <!-- 0.2 -->
        <section id="pour-qui">
            <h3>0.2 Pour qui est fait VITL&nbsp;?</h3>
            <div class="grid-2">
                <div>
                    <p><strong>Débutant</strong></p>
                    <ul>
                        <li>Apprendre sur une base saine : variables immuables par défaut, fonctions claires, erreurs
                            explicites.
                        </li>
                        <li>Éviter les pièges (pointeurs bruts, allocation manuelle) et se concentrer sur la logique.
                        </li>
                        <li>Progresser par étapes : <code>Result</code>, <code>match</code>, types/conversions,
                            lecture/écriture
                            de fichiers.</li>
                    </ul>

                    <p><strong>Développeur intermédiaire</strong></p>
                    <ul>
                        <li>Automatiser avec des scripts solides, relisibles et versionnables.</li>
                        <li>Créer des apps CLI portables (un binaire, zéro surprise d’environnement).</li>
                        <li>Profiter du formateur (<code>fmt</code>), de l’analyse (<code>check</code>) et des tests
                            (<code>test</code>).</li>
                    </ul>

                    <p><strong>Professionnel</strong></p>
                    <ul>
                        <li>Compiler en natif avec optimisation (<code>-O3</code>) et symboles de debug
                            (<code>-g</code>).</li>
                        <li>Interopérer avec la base C existante (FFI stable) ; emballer les appels <code>unsafe</code>
                            proprement.</li>
                        <li>Intégrer en CI/CD, produire la documentation depuis les commentaires <code>///</code>.</li>
                    </ul>
                </div>

                <div class="callout info">
                    <h4>Ce que vous ferez en 10 minutes</h4>
                    <ol>
                        <li>Créer <code>src/main.vitl</code> avec un “Hello” minimal.</li>
                        <li>Lancer <code>vitl run</code> pour tester en VM.</li>
                        <li>Compiler en natif avec <code>vitl build</code> et exécuter le binaire généré.</li>
                    </ol>
                    <p class="note">Pas de projet à “initialiser”, pas de configuration cachée : un fichier, une
                        commande, c’est
                        tout.</p>
                </div>
            </div>

            <div class="card">
                <strong>Parcours d’apprentissage conseillé</strong>
                <ol>
                    <li><em>Jour 1</em> : variables/fonctions, <code>println</code>, lecture d’un fichier, codes de
                        sortie
                        (0/1/2/3).</li>
                    <li><em>Jour 2</em> : <code>Result</code> + <code>?</code>, <code>match</code> exhaustif,
                        conversions
                        numériques et chaînes.</li>
                    <li><em>Jour 3</em> : structures (<code>struct</code>), méthodes (<code>impl</code>), petits tests
                        avec
                        <code>test "nom"</code>.
                    </li>
                    <li><em>Jour 4</em> : packaging des binaires, génération de doc, introduction au FFI.</li>
                </ol>
            </div>
        </section>

        <!-- 0.3 -->
        <section id="domaines">
            <h3>0.3 Domaines d'utilisation</h3>
            <ol>
                <li><strong>Scripts CLI robustes</strong> : parsing d’arguments, transformation de texte, traitements
                    batch
                    sur fichiers, petits ETL.</li>
                <li><strong>Exécutables natifs</strong> : outils internes distribuables sans dépendances, utilitaires
                    DevOps,
                    petits daemons.</li>
                <li><strong>Langage embarqué</strong> : pilotage d’un moteur, extension de logiciels C via chargement de
                    <code>.vitbc</code> ou FFI direct.
                </li>
            </ol>

            <div class="grid-2">
                <div class="card">
                    <strong>Patterns classiques</strong>
                    <ul>
                        <li>“Lire → transformer → écrire” (CSV/JSON/texte) avec erreurs explicites et logs sobres.</li>
                        <li>“Observer → réagir” (watcher de fichiers) en combinant VITL + utilitaires du système.</li>
                        <li>“Intégrer → encapsuler” un appel C via FFI dans une API VITL sûre.</li>
                    </ul>
                </div>
                <div class="callout warn">
                    <h4>Quand éviter VITL ?</h4>
                    <p>
                        Si votre cœur de besoin est un framework web complet, une UI riche multi-plateforme, ou une
                        concurrence
                        massive
                        multi-threads, vous serez plus efficace en déléguant ces aspects à un composant externe
                        (C/C++/Rust/Go) —
                        VITL reste un excellent <em>ciment</em> autour.
                    </p>
                </div>
            </div>
        </section>

        <!-- 0.4 -->
        <section id="points-forts">
            <h3>0.4 Points forts</h3>
            <ul>
                <li><strong>Syntaxe lisible et unifiée</strong> : mêmes règles, mêmes habitudes (identique à Vitte côté
                    forme).</li>
                <li><strong>Gestion mémoire simple</strong> : <code>Rc</code>/<code>Weak</code> pour la majorité des
                    cas, sans
                    GC complexe.</li>
                <li><strong>Erreurs explicites</strong> : <code>Result</code> + <code>?</code> pour propager simplement,
                    <code>match</code> exhaustif.
                </li>
                <li><strong>Stdlib pragmatique</strong> : I/O, fichiers, chaînes, dates/temps, maths, vecteurs, FFI.
                </li>
                <li><strong>Tooling intégré</strong> : <code>fmt</code>, <code>check</code>, <code>test</code>,
                    <code>doc</code>, IR/bytecode (<code>--emit-*</code>).
                </li>
                <li><strong>Livraison native</strong> : binaire unique, démarrage rapide, optimisation <code>-O3</code>.
                </li>
                <li><strong>FFI C stable</strong> : réutilisez l’existant au lieu de réécrire.</li>
            </ul>

            <div class="note">
                Besoin des détails sur les compromis (pas de threads natifs, etc.) ? Voir <a href="#limites">11)
                    Limites</a>.
            </div>
        </section>

        <!-- 0.5 -->
        <section id="hello">
            <h3>0.5 Exemple rapide (Hello World)</h3>
            <p>Créez <code>src/main.vitl</code> et collez :</p>
            <pre><code>module app.main
import std.io

fn main() -&gt; i32 {
  std.io::println("Bonjour Vitte Light")
  return 0
}
</code></pre>

            <div class="steps">
                <strong>Pas à pas</strong>
                <ol>
                    <li>Exécuter (VM) : <code>vitl run src/main.vitl</code></li>
                    <li>Compiler (natif) : <code>vitl build -O2 -o build/app src/main.vitl</code></li>
                    <li>Lancer le binaire : <code>./build/app</code> (Linux/macOS) ou <code>build\\app.exe</code>
                        (Windows)</li>
                </ol>
            </div>

            <div class="grid-2">
                <div class="card">
                    <strong>Variante : lire un argument</strong>
                    <pre><code>module app.main
import std.{io, cli, str}

fn main() -&gt; i32 {
  let argv = cli::args()
  if str::len(argv) &lt; 2 { io::eprintln("usage: app &lt;nom&gt;"); return 2 }
  io::println("Bonjour " + argv[1])
  return 0
}
</code></pre>
                </div>
                <div class="card">
                    <strong>Outils utiles dès maintenant</strong>
                    <pre><code># Formater
vitl fmt src/

# Analyser
vitl check src/

# Lancer les tests (dans les fichiers)
vitl test

# Générer doc depuis ///-commentaires
vitl doc src/ -o build/docs.txt
</code></pre>
                </div>
            </div>
        </section>

        <!-- 0.6 -->
        <section id="installation">
            <h3>0.6 Installation &amp; mise à jour</h3>
            <p>
                Téléchargez l’exécutable adapté à votre OS, placez-le dans votre <code>PATH</code> et vérifiez :
                <code>vitl --version</code>. Pour les environnements verrouillés, vous pouvez l’installer localement
                dans le
                projet
                (scripts CI/CD) et l’appeler via un chemin relatif.
            </p>
            <ul>
                <li><strong>Linux</strong> : rendez le binaire exécutable (<code>chmod +x</code>), copiez-le dans
                    <code>/usr/local/bin</code> ou ajoutez un dossier <code>bin/</code> à votre <code>PATH</code>.
                </li>
                <li><strong>macOS</strong> : glissez le binaire dans <code>/usr/local/bin</code> ou
                    <code>~/.local/bin</code>
                    et ajoutez-le à <code>PATH</code> dans votre shell.
                </li>
                <li><strong>Windows</strong> : placez <code>vitl.exe</code> dans un dossier référencé par <em>Variables
                        d’environnement → PATH</em>.</li>
            </ul>
            <p class="note">Astuce : en CI, mettez en cache le binaire VITL pour accélérer vos pipelines.</p>
        </section>

        <!-- 0.7 -->
        <section id="apercu-projet">
            <h3>0.7 Aperçu d’un projet minimal</h3>
            <pre><code>mon_projet/
  src/
    main.vitl        # module app.main
  build/             # artefacts (binaire, docs, bytecode)
</code></pre>
            <p>
                Un fichier = un module. Le nom du module correspond à son chemin disque (ex.
                <code>src/util/str.vitl</code> →
                <code>module util.str</code>).
                Importez explicitement ce que vous utilisez (<code>import std.io</code>, <code>import util.str</code>).
            </p>
        </section>

        <!-- 0.8 -->
        <section id="faq">
            <h3>0.8 FAQ express</h3>
            <p><strong>VITL a-t-il un ramasse-miettes ?</strong> Non, la mémoire est gérée par
                <code>Rc</code>/<code>Weak</code> : quand plus rien ne référence un objet, il est libéré.
            </p>
            <p><strong>Et les threads ?</strong> Pas de threads natifs dans la version Light ; utilisez des processus
                externes ou une lib C via FFI si c’est crucial.</p>
            <p><strong>Puis-je faire du réseau / des sockets ?</strong> Oui via la stdlib et/ou via FFI pour des stacks
                spécialisées.</p>
            <p><strong>Comment gérer les erreurs proprement ?</strong> Utilisez <code>Result&lt;T,E&gt;</code> et
                propagez
                avec <code>?</code> ; couvrez les cas avec <code>match</code>.</p>
        </section>

        <!-- 0.9 -->
        <section id="glossaire">
            <h3>0.9 Glossaire rapide</h3>
            <ul>
                <li><strong>VM</strong> : Machine virtuelle exécutant du bytecode <code>.vitbc</code> produit à la
                    volée.</li>
                <li><strong>FFI</strong> : Interface pour appeler des fonctions C (nécessite <code>unsafe</code> dans
                    des
                    zones confinées).</li>
                <li><strong><code>Result</code></strong> : type somme <code>Ok(T)</code>/<code>Err(E)</code> pour
                    modéliser
                    succès/échec.</li>
                <li><strong><code>match</code></strong> : sélection de motifs obligeant à couvrir tous les cas (donc
                    moins
                    d’implicite).</li>
            </ul>
        </section>

        <!-- 0.10 -->
        <section id="ou-aller-apres">
            <h3>0.10 Où aller ensuite ?</h3>
            <p>
                Explorez <a href="#structure">1) Structure de projet</a> pour organiser vos fichiers, puis
                <a href="#syntaxe">3) Syntaxe</a> pour ancrer les bases (variables, <code>match</code>,
                <code>Result</code>).
                Besoin de livrer ? Lisez <a href="#cli">2) Outils en ligne de commande</a>.
                Intégration C ? Voir <a href="#ffi">7) FFI</a>. Enfin, gardez un œil sur <a href="#limites">11)
                    Limites</a>
                pour comprendre
                les compromis qui gardent VITL rapide et prévisible.
            </p>
        </section>
    </section>


    <!-- 1) STRUCTURE -->
    <section id="structure">
        <h2>1) Structure de projet — Guide complet</h2>

        <div class="callout info">
            <h4>En clair</h4>
            <p>Trois dossiers suffisent&nbsp;: <code>/src</code> (code VITL), <code>/libs</code> (C/FFI),
                <code>/build</code> (artefacts). Cette séparation garde les sources propres, facilite les revues et les
                pipelines CI.
            </p>
        </div>

        <p>
            Une structure claire évite des heures perdues&nbsp;: on sait où créer un fichier, où trouver une
            fonctionnalité,
            où tombent les binaires.
            Cette section propose une arborescence <em>de base</em> puis des variantes (simple → complexe), des
            conventions
            de nommage,
            des exemples <em>copier/coller</em> (<code>.gitignore</code>, tâches build, CI), et des intégrations C
            (CMake/Meson).
        </p>

        <h3>1.1 Arborescence type minimale</h3>
        <pre><code>/src   → code source principal (.vitl)
/libs  → bibliothèques natives C/FFI (.c, .so, .dll, .a)
/build → binaires, artefacts intermédiaires, bytecode (.vitbc)

mon_projet/
  src/
    main.vitl
    util/str.vitl
  libs/
    mylib.c
    mylib.a
  build/
    app        (binaire natif)
    app.vitbc  (bytecode)
</code></pre>

        <h3>1.2 Convention des modules</h3>
        <ul>
            <li>Un fichier = un module.</li>
            <li>Chemin disque = nom de module (lisible et prédictible).</li>
            <li>Noms en <code>snake.case</code> pour modules/fichiers, <code>CamelCase</code> pour types.</li>
        </ul>
        <pre><code>Fichier : src/std/io.vitl
Contenu : module std.io

Fichier : src/app/http/client.vitl
Contenu : module app.http.client
</code></pre>
        <p>Imports clairs&nbsp;: <code>import std.io</code>, <code>import util.str</code>. Évite les conflits, favorise
            la
            réutilisation.</p>

        <div class="callout ok">
            <h4>Raison pratique</h4>
            <p>Quand le chemin et le module correspondent, on sait toujours <em>où</em> vit une fonction. Plus simple
                pour
                les revues, la navigation IDE et la CI.</p>
        </div>

        <h3>1.3 Variantes d’organisation (selon la taille)</h3>
        <div class="grid-2">
            <div class="card">
                <strong>Projet simple</strong>
                <pre><code>mon_projet/
  src/main.vitl
  src/util/print.vitl
  build/
</code></pre>
                <p>Objectif&nbsp;: aller vite. Tests intégrés au bas des fichiers.</p>
            </div>
            <div class="card">
                <strong>Projet moyen</strong>
                <pre><code>mon_projet/
  src/app/main.vitl
  src/app/cli/args.vitl
  src/std/extra/time.vitl
  src/util/fs.vitl
  libs/fast.c
  build/{debug,release,docs}
</code></pre>
                <p>On sépare <code>app/</code>, <code>util/</code>, <code>std/</code> local. Dossiers
                    <code>debug/</code> et
                    <code>release/</code> dans <code>build/</code>.
                </p>
            </div>
        </div>

        <div class="card">
            <strong>Projet complexe (modulaire)</strong>
            <pre><code>mon_projet/
  src/
    app/main.vitl
    app/sub/feature.vitl
    core/error.vitl
    core/config.vitl
    net/http.vitl
    net/tcp.vitl
    std/extra/...
  tests/
    test_core.vitl
    test_net.vitl
  libs/
    sqlite/sqlite3.c
    wrapper/foo.c
  build/
    debug/
    release/
    docs/
  scripts/
    build.sh
    release.sh
  docs/
    README.md
    CHANGELOG.md
</code></pre>
            <p>Tests isolés dans <code>/tests</code>, scripts utilitaires dans <code>/scripts</code>, documentation
                dédiée
                dans <code>/docs</code>.</p>
        </div>

        <h3>1.4 Rôles des dossiers (rappel express)</h3>
        <ul>
            <li><code>/src</code>&nbsp;: code VITL uniquement (modules, types, fonctions, tests intégrés).</li>
            <li><code>/libs</code>&nbsp;: code C/C++ <em>enveloppé</em> côté C (shim) pour exposer une API C stable.
            </li>
            <li><code>/build</code>&nbsp;: non versionné&nbsp;; binaires, <code>.vitbc</code>, docs générées, artefacts
                temporaires.</li>
            <li><code>/tests</code> (optionnel)&nbsp;: scénarios et jeux de données.</li>
            <li><code>/scripts</code> (optionnel)&nbsp;: tâches build/release reproductibles.</li>
            <li><code>/docs</code> (optionnel)&nbsp;: guides, captures, changelog, spécifications.</li>
        </ul>

        <h3>1.5 Conventions de nommage</h3>
        <ul>
            <li>Modules/fichiers&nbsp;: <code>snake.case</code> (<code>net/http.vitl</code> →
                <code>module net.http</code>).
            </li>
            <li>Types&nbsp;: <code>CamelCase</code> (<code>struct HttpClient</code>).</li>
            <li>Fonctions/variables&nbsp;: <code>snake_case</code> (<code>fn read_config()</code>).</li>
            <li>Tests&nbsp;: <code>test "nom explicite du comportement"</code>.</li>
        </ul>

        <h3>1.6 Chemins &amp; portabilité (Linux/macOS/Windows)</h3>
        <ul>
            <li>Utilisez des chemins relatifs au projet (évite les surprises en CI).</li>
            <li>Évitez de coder en dur <code>\\</code> ou <code>/</code>&nbsp;: centralisez la logique de chemins si
                nécessaire.</li>
            <li>Stockez les fichiers de test dans <code>tests/data/</code> et adressez-les via <code>std.fs</code>
                depuis la
                racine.</li>
        </ul>

        <h3>1.7 Tests&nbsp;: où les placer&nbsp;?</h3>
        <ul>
            <li><strong>Petit projet</strong>&nbsp;: tests à la fin de chaque fichier.</li>
            <li><strong>Projet moyen/complexe</strong>&nbsp;: combiner tests intégrés + scénarios dans
                <code>/tests</code>.
            </li>
        </ul>
        <pre><code>src/core/math.vitl
  ... code ...
  test "somme de base" { assert(add(1,2) == 3) }

tests/test_math.vitl
  ... scénarios plus riches, I/O, golden files ...
</code></pre>

        <h3>1.8 Documentation générée</h3>
        <p>Documentez vos APIs avec <code>///</code> en tête d’éléments publics, puis générez avec
            <code>vitl doc src/ -o build/docs.txt</code>. Conservez les docs “métier” plus longues dans
            <code>/docs</code>.
        </p>

        <h3>1.9 Sorties de build (organisation)</h3>
        <pre><code>/build/
  debug/     → binaires -O0 -g (débogage)
  release/   → binaires -O3 (livraison)
  docs/      → doc générée (ex. docs.txt)
  *.vitbc    → bytecode (exécution VM)
</code></pre>

        <h3>1.10 Fichier .gitignore (copier/coller)</h3>
        <pre><code># VITL
/build/
*.vitbc

# OS
.DS_Store
Thumbs.db

# Éditeurs/IDE
.vscode/
.idea/
*.iml

# Logs/temp
*.log
.tmp/
.cache/
</code></pre>

        <h3>1.11 Tâches build pratiques</h3>
        <div class="grid-2">
            <div class="card">
                <strong>bash (Linux/macOS)</strong>
                <pre><code># scripts/build.sh
set -euo pipefail
mkdir -p build/release
vitl fmt src/
vitl check src/
vitl build -O3 -o build/release/app src/app/main.vitl
echo "OK → build/release/app"
</code></pre>
            </div>
            <div class="card">
                <strong>PowerShell (Windows)</strong>
                <pre><code># scripts/build.ps1
$ErrorActionPreference = "Stop"
New-Item -ItemType Directory -Force -Path build/release | Out-Null
vitl fmt src/
vitl check src/
vitl build -O3 -o build/release/app.exe src/app/main.vitl
Write-Host "OK → build/release/app.exe"
</code></pre>
            </div>
        </div>

        <h3>1.12 Intégration CI (GitHub Actions minimal)</h3>
        <pre><code># .github/workflows/ci.yml
name: CI
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install VITL
        run: |
          mkdir -p ~/bin
          curl -L &lt;URL_VITL_LINUX&gt; -o ~/bin/vitl
          chmod +x ~/bin/vitl
          echo "$HOME/bin" >> $GITHUB_PATH
      - name: Format &amp; Check
        run: |
          vitl fmt src/
          vitl check src/
      - name: Tests
        run: vitl test
      - name: Build (release)
        run: vitl build -O3 -o build/release/app src/app/main.vitl
      - name: Upload artefacts
        uses: actions/upload-artifact@v4
        with:
          name: app-linux
          path: build/release/app
</code></pre>
        <p class="note">Adaptez l’étape “Install VITL” à votre source de binaire (URL/paquet interne).</p>

        <h3>1.13 Intégration d’une lib C (FFI) — CMake</h3>
        <pre><code># libs/CMakeLists.txt
cmake_minimum_required(VERSION 3.16)
project(vitl_ffi C)
add_library(foo STATIC foo.c)
target_include_directories(foo PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
</code></pre>
        <pre><code># Construire la lib puis lier côté VITL
mkdir -p libs/build &amp;&amp; cd libs/build
cmake ..
cmake --build . --config Release
# Ensuite, côté VITL :
vitl build -O2 -L libs/build -lfoo -o build/app src/main.vitl
</code></pre>

        <h3>1.14 Intégration d’une lib C (FFI) — Meson</h3>
        <pre><code># libs/meson.build
project('vitl_ffi', 'c')
libfoo = static_library('foo', 'foo.c', include_directories: include_directories('.'))
</code></pre>
        <pre><code># Build Meson/Ninja
meson setup libs/build libs
meson compile -C libs/build
# Puis lier lors du build VITL :
vitl build -O2 -L libs/build -lfoo -o build/app src/main.vitl
</code></pre>

        <h3>1.15 Packaging &amp; release</h3>
        <ul>
            <li>Générez le binaire <code>release/</code> (<code>-O3</code>) pour chaque OS visé.</li>
            <li>Ajoutez un README court par plateforme&nbsp;: commande, options, exemples.</li>
            <li>Incluez <code>LICENSE</code>, <code>CHANGELOG.md</code> et un hash (SHA256) des binaires.</li>
            <li>Option&nbsp;: archivez <code>app</code> + fichiers d’exemple (<code>examples/</code>).</li>
        </ul>

        <h3>1.16 Versionning &amp; docs projet</h3>
        <ul>
            <li><code>CHANGELOG.md</code> (Keep a Changelog&nbsp;: Added/Changed/Fixed/Removed).</li>
            <li><code>README.md</code>&nbsp;: but, installation, quick start, table des commandes.</li>
            <li>Tagguez vos versions (tags Git)&nbsp;; automatisez un brouillon de release en CI.</li>
        </ul>

        <h3>1.17 Fichiers de configuration (exemples)</h3>
        <div class="grid-2">
            <div class="card">
                <strong>README.md (squelette)</strong>
                <pre><code># Mon Projet VITL
But&nbsp;: une ligne claire ici.

## Installation
- Télécharger le binaire.
- Ajouter au PATH.

## Utilisation
\`\`\`sh
vitl --help
\`\`\`
</code></pre>
            </div>
            <div class="card">
                <strong>.editorconfig</strong>
                <pre><code>root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
trim_trailing_whitespace = true
</code></pre>
            </div>
        </div>
    </section>



    <!-- 2) CLI -->
    <section id="cli">
        <h2>2) Outils en ligne de commande — Guide ultra-complet</h2>

        <div class="callout info">
            <h4>Vue d’ensemble</h4>
            <ul>
                <li><code>vitl run &lt;fichier.vitl&gt; [-- args...]</code> — compile en bytecode puis exécute dans la
                    VM
                    (idéal pour apprendre, prototyper, CI rapide).</li>
                <li><code>vitl build [options] -o &lt;sortie&gt; &lt;fichier.vitl&gt;</code> — produit un exécutable
                    natif
                    (livraison, perf).</li>
                <li><code>vitl fmt &lt;chemin&gt;</code> — formateur de code (style standard).</li>
                <li><code>vitl check &lt;chemin&gt;</code> — analyse statique (imports, types, diagnostics rapides).
                </li>
                <li><code>vitl test</code> — exécute tous les blocs <code>test "…"{…}</code> rencontrés.</li>
                <li><code>vitl doc &lt;chemin&gt; -o &lt;fichier&gt;</code> — génère la doc à partir des commentaires
                    <code>///</code>.
                </li>
            </ul>
        </div>

        <h3>2.1 Exécution immédiate (VM/JIT)</h3>
        <pre><code># Lancer un fichier
vitl run src/main.vitl

# Passer des arguments utilisateur au programme (utilisez -- pour séparer)
vitl run src/cat.vitl -- README.md

# Exécuter plusieurs fichiers (point d’entrée = premier fichier avec fn main)
vitl run src/app/main.vitl src/util/str.vitl
</code></pre>
        <ul>
            <li><strong>Quand l’utiliser</strong> : démo, TDD rapide, scripts éphémères, validation CI sans build natif.
            </li>
            <li><strong>Bon à savoir</strong> : la VM applique les mêmes vérifications que le build (types, imports,
                sécurité).</li>
        </ul>

        <h3>2.2 Compilation en exécutable natif</h3>
        <pre><code># Build simple (optimisation par défaut -O2)
vitl build -o build/app src/main.vitl

# Profils typiques
vitl build -O0 -g -o build/debug/app    src/main.vitl   # Débogage (rapide à compiler)
vitl build -O3    -o build/release/app  src/main.vitl   # Livraison (perf max)

# Émettre des artefacts intermédiaires
vitl build --emit-ir       -o build/app src/main.vitl   # IR lisible
vitl build --emit-bytecode -o build/app src/main.vitl   # Bytecode VM (.vitbc)
</code></pre>
        <div class="callout ok">
            <h4>Conseils</h4>
            <ul>
                <li>Utilisez <code>-O0 -g</code> en dev pour des builds rapides + backtraces lisibles.</li>
                <li>Pour livrer, préférez <code>-O3</code>, mesurez, puis ajustez (I/O, allocations, FFI).</li>
            </ul>
        </div>

        <h3>2.3 Formateur, analyseur, tests, doc</h3>
        <pre><code># Formater tout le code (à intégrer en pre-commit)
vitl fmt src/

# Analyse statique (imports manquants, types, règles de base)
vitl check src/

# Tests intégrés (cherche et exécute tous les blocs `test "..." {}`)
vitl test

# Documentation à partir des commentaires /// en tête d’API publiques
vitl doc src/ -o build/docs.txt
</code></pre>

        <h3>2.4 Lier des bibliothèques C (FFI)</h3>
        <pre><code># Fichiers de shim C compilés séparément dans libs/
# Lier une lib partagée ou statique pendant le build
vitl build -O2 -L libs -lfoo -o build/app src/main.vitl

# Définir un rpath pour retrouver les .so/.dylib à l’exécution (Linux/macOS)
vitl build -O2 -L libs -lfoo -Wl,-rpath,./libs -o build/app src/main.vitl
</code></pre>
        <ul>
            <li><strong>-L</strong> : ajoute un chemin de recherche des bibliothèques.</li>
            <li><strong>-lfoo</strong> : lie la bibliothèque <code>libfoo.{so,dylib,a}</code>.</li>
            <li><strong>Astuce</strong> : conservez un <em>shim C plat</em> (types stables, ownership clair) pour un FFI
                robuste.</li>
        </ul>

        <h3>2.5 Exemples concrets (sessions)</h3>
        <pre><code># Hello World (VM puis binaire)
vitl run   src/main.vitl
vitl build -O2 -o build/hello src/main.vitl
./build/hello
</code></pre>
        <pre><code># Programme CLI avec arguments et codes d’erreur
vitl run src/cat.vitl -- data.txt     # 0 si succès, 2 usage, 3 I/O
vitl build -O2 -o build/cat src/cat.vitl
./build/cat data.txt
echo $?   # vérifie le code de sortie
</code></pre>
        <pre><code># Pipeline CI local minimal (bash)
set -euo pipefail
vitl fmt src/
vitl check src/
vitl test
vitl build -O3 -o build/release/app src/app/main.vitl
</code></pre>

        <h3>2.6 Débogage &amp; diagnostics</h3>
        <ul>
            <li>Compilez avec <code>-g</code> pour obtenir des backtraces plus utiles.</li>
            <li>En VM (<code>vitl run</code>), les messages d’erreur incluent le module et la ligne fautive.</li>
            <li>Utilisez <code>--emit-ir</code>/<code>--emit-bytecode</code> pour comprendre ce que “voit” le
                compilateur.</li>
        </ul>

        <h3>2.7 Organisation des sorties</h3>
        <pre><code>mkdir -p build/{debug,release,docs}
vitl build -O0 -g -o build/debug/app   src/app/main.vitl
vitl build -O3    -o build/release/app src/app/main.vitl
vitl doc src/ -o build/docs/api.txt
</code></pre>

        <h3>2.8 Bonnes pratiques (tous niveaux)</h3>
        <ul>
            <li><strong>Débutant</strong> : <code>vitl run</code> + <code>vitl fmt</code>. Gardez un seul fichier
                <code>main.vitl</code> au début.
            </li>
            <li><strong>Intermédiaire</strong> : ajoutez <code>vitl check</code>, factorisez en modules, commencez à
                tester (<code>vitl test</code>).</li>
            <li><strong>Pro</strong> : CI (fmt/check/test/build), doc générée, profilage simple, FFI maîtrisé (règles
                d’ownership).</li>
        </ul>

        <h3>2.9 Problèmes fréquents &amp; solutions</h3>
        <div class="grid-2">
            <div class="card">
                <strong>“Permission denied” au lancement</strong>
                <ul>
                    <li>Linux/macOS : <code>chmod +x build/app</code>, exécuter <code>./build/app</code>.</li>
                    <li>Windows : exécuter <code>build\\app.exe</code> directement.</li>
                </ul>
            </div>
            <div class="card">
                <strong>Options mal placées</strong>
                <ul>
                    <li>Placez <code>-o</code> après <code>build</code> :
                        <code>vitl build -O2 -o build/app src/main.vitl</code>.
                    </li>
                    <li>Les arguments au programme se placent après <code>--</code> :
                        <code>vitl run file.vitl -- arg1</code>.
                    </li>
                </ul>
            </div>
        </div>

        <h3>2.10 Table de référence rapide</h3>
        <div class="card">
            <ul>
                <li><code>run</code> : exécuter via VM — <em>rapide à itérer</em>.</li>
                <li><code>build</code> : binaire natif — <em>déploiement/perf</em>.</li>
                <li><code>fmt</code> : style cohérent — <em>revues plus simples</em>.</li>
                <li><code>check</code> : diagnostics — <em>trouve tôt les erreurs</em>.</li>
                <li><code>test</code> : qualité — <em>régression évitée</em>.</li>
                <li><code>doc</code> : API — <em>autodoc depuis <code>///</code></em>.</li>
                <li>Options clés : <code>-O0|-O1|-O2|-O3</code>, <code>-g</code>, <code>-o</code>,
                    <code>--emit-ir</code>,
                    <code>--emit-bytecode</code>, <code>-L</code>, <code>-lX</code>, <code>-Wl,opts</code>.
                </li>
            </ul>
        </div>

        <p class="card"><strong>Résumé</strong> — Utilisez <code>run</code> pour explorer, <code>build</code> pour
            livrer. Automatisez <code>fmt</code>/<code>check</code>/<code>test</code> en CI. Inspectez avec
            <code>--emit-ir</code>/<code>--emit-bytecode</code>. Pour le FFI, liez proprement avec
            <code>-L</code>/<code>-l</code> et un <em>shim</em> C clair.
        </p>
    </section>

    <hr />

    <!-- 3) SYNTAXE -->
    <section id="syntaxe">
        <h2>3) Syntaxe : découverte progressive</h2>

        <div class="callout info">
            <h4>Pour les débutants (d’abord l’intuition)</h4>
            <p>Un programme VITL est une suite d’instructions lues de haut en bas. Vous donnez des
                <em>noms</em> à des valeurs (variables), vous <em>définissez</em> des fonctions (recettes
                réutilisables),
                vous <em>contrôlez</em> l’ordre d’exécution (si/alors, boucles), et vous <em>gérez</em> les erreurs
                proprement (<code>Result</code> et <code>?</code>).
            </p>
            <ul>
                <li>Variables <strong>immuables</strong> par défaut ; ajoutez <code>mut</code> si la valeur doit
                    changer.</li>
                <li>Les erreurs se gèrent avec <code>Result</code> (succès/échec) et se <em>propagent</em> avec
                    <code>?</code>.
                </li>
                <li><code>match</code> oblige à traiter tous les cas possibles (moins de surprises).</li>
                <li>Un fichier = un module : <code>src/util/str.vitl</code> → <code>module util.str</code>.</li>
                <li>Deux types de chaînes : <code>str</code> (vue immuable, légère) vs <code>String</code> (possédée,
                    mutable).</li>
            </ul>
        </div>

        <h3>3.0 Votre premier “mini-lab” (2 minutes)</h3>
        <ol>
            <li>Créez <code>src/play.vitl</code> avec le contenu ci-dessous.</li>
            <li>Lancez <code>vitl run src/play.vitl</code> et observez la sortie.</li>
        </ol>
        <pre><code>module app.play
import std.io

fn main() -&gt; i32 {
  let msg = "Bonjour"        // immuable
  let mut n = 1              // mutable
  n = n + 1
  std.io::println(msg + " n=" + n.to_string())
  return 0
}
// Sortie attendue : Bonjour n=2
</code></pre>

        <h3>3.1 Commentaires &amp; documentation</h3>
        <p>Les commentaires expliquent <em>pourquoi</em> (pas juste “ce que ça fait”). Les commentaires de doc
            (<code>///</code>) apparaissent dans <code>vitl doc</code>.</p>
        <pre><code>// Ligne unique
/* Bloc multi-lignes */

/// Additionne deux entiers (sans débordement contrôlé)
fn add(a:i32, b:i32) -&gt; i32 { return a + b }
</code></pre>

        <h3>3.2 Nommage lisible (conseils débutant)</h3>
        <ul>
            <li>Variables/fonctions en <code>snake_case</code>, types en <code>CamelCase</code>.</li>
            <li>Un bon nom évite des commentaires : préférez <code>max_retries</code> à <code>mr</code>.</li>
        </ul>
        <pre><code>let user_name = "Alice"
struct Point2D { x:f64, y:f64 }
</code></pre>

        <h3>3.3 Types de base &amp; littéraux</h3>
        <p>Pas besoin de tout retenir : l’éditeur et les erreurs vous guident.</p>
        <ul>
            <li>Entiers : <code>i32</code>, <code>i64</code> (ex. <code>42</code>, <code>0xFF</code>,
                <code>0b1010</code>)
            </li>
            <li>Flottants : <code>f64</code> (ex. <code>3.14</code>, <code>2.0e-3</code>)</li>
            <li>Booléens : <code>true</code>, <code>false</code></li>
            <li>Caractères : <code>'a'</code>, <code>'\n'</code></li>
            <li>Chaînes UTF-8 : <code>"..."</code> ou brutes <code>r"..."</code></li>
        </ul>
        <pre><code>const PI:f64 = 3.14159
let ok:bool = true
let hex:i32 = 0xCAFE
</code></pre>

        <h3>3.4 Variables, constantes, mutabilité</h3>
        <p>Immuable par défaut = code plus sûr. Ajoutez <code>mut</code> uniquement où nécessaire.</p>
        <pre><code>const MAX_RETRY:i32 = 3         // constante
let count:i32 = 0               // immuable
let mut total:f64 = 0.0         // mutable
total = total + 1.5

// Inférence de type quand c'est clair
let message = "Salut"  // :str
</code></pre>

        <h3>3.5 Opérateurs &amp; conversions</h3>
        <p>VITL évite les conversions implicites “magiques”. Convertissez avec <code>as</code> (numérique) ou
            <code>to_string()</code> (texte).
        </p>
        <pre><code>let n:i32 = 3
let x:f64 = 0.5
let y = (n as f64) + x          // cast requis

std.io::println("n=" + n.to_string())  // convertir avant concaténation
</code></pre>

        <h3>3.6 Chaînes : <code>str</code> vs <code>String</code> (images mentales)</h3>
        <ul>
            <li><code>str</code> : “post-it” vers un texte (on ne le modifie pas).</li>
            <li><code>String</code> : “carnet” qui vous appartient (on peut écrire dedans).</li>
        </ul>
        <pre><code>let s:str = "abc"
let mut buf = String::from("abc")
buf.push("d")            // "abcd"
std.io::println(buf)
</code></pre>

        <h3>3.7 Collections, slices &amp; boucles</h3>
        <p>Les indices sont vérifiés : une erreur claire vaut mieux qu’un crash silencieux.</p>
        <pre><code>let mut v:[i32] = [1,2,3]
v.push(4)
for x in &amp;v { std.io::println(x.to_string()) }
let third = v[2]   // panique si hors bornes → message explicite
</code></pre>

        <h3>3.8 Contrôle de flux (recettes courantes)</h3>
        <pre><code>// if / else
if y &gt; 0.0 { std.io::println("positif") } else { std.io::println("non positif") }

// while
let mut i = 0
while i &lt; 3 { std.io::println(i.to_string()); i = i + 1 }

// for + intervalles
for k in 0..3  { std.io::println(k.to_string()) }   // 0,1,2
for k in 0..=3 { std.io::println(k.to_string()) }   // 0..3 inclus

// break / continue
for n in 0..10 {
  if n == 5 { break }
  if n % 2 == 0 { continue }
  std.io::println(n.to_string())
}
</code></pre>

        <h3>3.9 Fonctions (penser “boîte noire”)</h3>
        <p>Une fonction prend des <em>entrées</em>, produit des <em>sorties</em>, et peut signaler un échec avec
            <code>Result</code>.
            VITL <em>n’infère pas</em> le type de retour : écrivez-le.
        </p>
        <pre><code>// Paramètres nommés et type de retour explicite
fn square(x:i32) -&gt; i32 { return x * x }

// Valeur ou erreur (Result)
fn div(a:i32, b:i32) -&gt; Result&lt;i32, str&gt; {
  if b == 0 { return Result::Err("division par zéro") }
  return Result::Ok(a / b)
}

// Passer par référence pour éviter une copie lourde
fn print_len(s:&amp;String) -&gt; () {
  std.io::println(s.len().to_string())
}
</code></pre>
        <div class="callout ok">
            <h4>Astuce</h4>
            <p>Gardez des fonctions <em>courtes</em> qui font une seule chose ; préférez retourner <code>Result</code>
                plutôt que d’appeler <code>panic()</code>.</p>
        </div>

        <h3>3.10 Erreurs : <code>Result</code>, <code>Option</code> et opérateur <code>?</code></h3>
        <p><code>Result&lt;T,E&gt;</code> représente un succès (<code>Ok(T)</code>) ou un échec (<code>Err(E)</code>).
            L’opérateur <code>?</code> “bulle”
            l’erreur au dessus : s’il y a <code>Err</code>, la fonction courante s’arrête et renvoie cette erreur.</p>
        <pre><code>// I/O : propage l’erreur si le fichier est introuvable/illisible
fn load(path:str) -&gt; Result&lt;String, str&gt; {
  let txt = std.fs::read_to_string(path)?   // &lt;— propage
  return Result::Ok(txt)
}

// Valeur optionnelle (présence/absence)
match std.cli::env("HOME") {
  Some(h) =&gt; std.io::println(h),
  None    =&gt; std.io::eprintln("HOME non défini"),
}
</code></pre>

        <h3>3.11 <code>match</code> exhaustif &amp; enums</h3>
        <p><code>match</code> impose de couvrir tous les cas (soit explicitement, soit via <code>_</code> pour “autre”).
        </p>
        <pre><code>enum Status { Ok, Err(str) }

fn report(s:Status) -&gt; () {
  match s {
    Status::Ok     =&gt; std.io::println("ok"),
    Status::Err(e) =&gt; std.io::eprintln("erreur:" + e),
  }
}
</code></pre>

        <h3>3.12 Structs, méthodes (<code>impl</code>) et récepteurs <code>&amp;self</code></h3>
        <p>Les méthodes se définissent dans un bloc <code>impl</code>. <code>&amp;self</code> signifie “emprunter
            l’objet
            sans le copier”.</p>
        <pre><code>struct Vec2 { x:f64, y:f64 }

impl Vec2 {
  fn norm(&amp;self) -&gt; f64 { return (self.x*self.x + self.y*self.y).sqrt() }
  fn dot(&amp;self, o:Vec2) -&gt; f64 { return self.x*o.x + self.y*o.y }
}

fn main() -&gt; i32 {
  let v = Vec2 { x:3.0, y:4.0 }
  std.io::println(v.norm().to_string())  // 5
  return 0
}
</code></pre>

        <h3>3.13 Modules &amp; imports (organisation du code)</h3>
        <p>Le <strong>chemin disque</strong> détermine le <strong>nom de module</strong>. Gardez cette règle et vous
            saurez toujours “où vit quoi”.</p>
        <pre><code>// Fichier : src/util/str.vitl
module util.str
// ... API ...

// Fichier : src/app/main.vitl
module app.main
import std.{io, fs}
import util.str

fn main()-&gt;i32 {
  std.io::println("Ready")
  return 0
}
</code></pre>

        <h3>3.14 Génériques (usage simple)</h3>
        <p>La version Light supporte des génériques “légers” pour des cas typiques (fonctions d’ordre supérieur,
            conteneurs simples).</p>
        <pre><code>// Exécuter une fonction et mesurer son temps
fn timed&lt;F&gt;(label:str, f:F) -&gt; ()
where F: fn()-&gt;() {
  let t0 = std.time::now()
  f()
  std.io::println(label + ":" + (std.time::now()-t0).to_string() + " ms")
}
</code></pre>

        <h3>3.15 Formats d’entrées/sorties (console &amp; fichiers)</h3>
        <pre><code>// Console
std.io::print("sans retour")
std.io::println("avec retour")
std.io::eprintln("erreur: usage invalide")

// Fichiers
_ = std.fs::write_string("out.txt", "ok\n")?
let txt = std.fs::read_to_string("out.txt")?
</code></pre>

        <h3>3.16 Bonnes pratiques (tous niveaux)</h3>
        <ul>
            <li>Déclarez les <em>types de retour</em> des fonctions (lisibilité, erreurs plus claires).</li>
            <li>Préférez <code>Result</code> + <code>?</code> à des codes sentinelles.</li>
            <li>Validez tôt l’entrée (fail-fast) et produisez des messages d’erreur utiles.</li>
            <li>Séparez vos modules par responsabilité (util, io, app, …).</li>
        </ul>

        <h3>3.17 Pièges fréquents (et correctifs)</h3>
        <div class="grid-2">
            <div class="card">
                <strong>E0001 : symbole inconnu</strong>
                <pre><code>// Mauvais
module app.main
fn main()-&gt;i32 { std.io::pritnln("hi"); return 0 }

// Correct
module app.main
import std.io
fn main()-&gt;i32 { std.io::println("hi"); return 0 }
</code></pre>
            </div>
            <div class="card">
                <strong>E0002 : types incompatibles</strong>
                <pre><code>// Mauvais
let n:i32 = 3
std.io::println("n=" + n)

// Correct
std.io::println("n=" + n.to_string())
</code></pre>
            </div>
        </div>

        <h3>3.18 Exercices guidés (à vous de jouer)</h3>
        <ol>
            <li><strong>Convertisseur</strong> : lisez un nombre depuis la ligne de commande et affichez son double
                (gérez
                l’erreur si l’argument manque).</li>
            <li><strong>Concat</strong> : créez une <code>String</code>, ajoutez-y trois morceaux (<code>push</code>),
                affichez le résultat.</li>
            <li><strong>Vec2</strong> : reprenez la struct <code>Vec2</code>, ajoutez une méthode
                <code>scale(&amp;mut self, k:f64)</code>, testez-la.
            </li>
        </ol>

        <div class="card">
            <strong>Aide-mémoire (quick ref)</strong>
            <ul>
                <li><code>let</code>/<code>let mut</code> · <code>const</code> · <code>fn</code> · <code>struct</code> ·
                    <code>enum</code> · <code>impl</code>
                </li>
                <li><code>if</code> / <code>while</code> / <code>for</code> avec <code>0..N</code> et <code>0..=N</code>
                </li>
                <li>Erreurs : <code>Result</code> + <code>?</code> · Absence : <code>Option</code></li>
                <li>I/O : <code>std.io</code> · Fichiers : <code>std.fs</code> · Chaînes : <code>std.str</code></li>
                <li>Organisation : un fichier = un module ; imports groupés ; tests en bas de fichier.</li>
            </ul>
        </div>
    </section>

    <!-- 4) EXEMPLES -->
    <section id="exemples">
        <h2>4) Premiers exemples — ultra détaillés (spécial débutants)</h2>

        <div class="callout info">
            <h4>Objectif</h4>
            <p>Écrire, exécuter, compiler, tester et diagnostiquer des programmes VITL pas à pas.
                Chaque exemple inclut : le code, la commande pour l’exécuter, la sortie attendue, des variantes,
                des tests et les erreurs fréquentes.</p>
        </div>

        <h3>4.0 Avant de commencer</h3>
        <ol>
            <li>Créez un dossier de travail (ex. <code>vitte-light-demo/</code>).</li>
            <li>À l’intérieur, créez <code>src/</code> et <code>build/</code>.</li>
            <li>Chaque exemple ci-dessous suppose que les fichiers sont dans <code>src/</code>.</li>
        </ol>
        <p class="note">Commandes clés : <code>vitl run &lt;fichier.vitl&gt;</code> (exécution rapide) ·
            <code>vitl build -O2 -o build/app &lt;fichier.vitl&gt;</code> (binaire natif) ·
            <code>vitl fmt src/</code> (formateur) · <code>vitl test</code> (tests intégrés).
        </p>

        <!-- 4.1 -->
        <h3>4.1 Débutant → programme minimal (Hello + variables + concat)</h3>
        <pre><code>// src/main.vitl
module app.main
import std.io

fn main() -&gt; i32 {
  let msg = "Bonjour Vitte Light"
  let mut n = 1
  n = n + 1
  std.io::println(msg + " · n=" + n.to_string())
  return 0
}
</code></pre>
        <p><strong>Exécution</strong> : <code>vitl run src/main.vitl</code></p>
        <p><strong>Sortie attendue</strong> : <code>Bonjour Vitte Light · n=2</code></p>
        <div class="callout ok">
            <h4>Ce que vous apprenez</h4>
            <ul>
                <li>Fichier = module (<code>module app.main</code>).</li>
                <li>Immuable par défaut, <code>mut</code> pour modifier.</li>
                <li>Concaténer du texte → convertir les nombres avec <code>.to_string()</code>.</li>
            </ul>
        </div>
        <div class="callout warn">
            <h4>Erreurs fréquentes</h4>
            <ul>
                <li><strong>E0001</strong> <em>symbole inconnu</em> : oubli de <code>import std.io</code> ou faute de
                    frappe
                    (<code>pritnln</code>).</li>
                <li><strong>E0002</strong> <em>types incompatibles</em> : concaténer un nombre sans
                    <code>.to_string()</code>.
                </li>
            </ul>
        </div>
        <details>
            <summary>Variantes utiles</summary>
            <pre><code>// A) Bonjour personnalisé via variable
module app.hello
import std.io
fn main()-&gt;i32 {
  let name = "Alice"
  std.io::println("Bonjour, " + name)
  return 0
}

// B) Codes de sortie (1 = erreur générique)
module app.exit
import std.io
fn main()-&gt;i32 {
  if 2 + 2 != 4 {
    std.io::eprintln("arithmétique cassée")
    return 1
  }
  return 0
}
</code></pre>
        </details>
        <h4>Tests (mini TDD)</h4>
        <pre><code>// Ajoutez à la fin de src/main.vitl :
test "arithmétique de base" { assert(2 + 2 == 4) }
</code></pre>
        <p><strong>Lancez</strong> : <code>vitl test</code> → affichera les tests réussis.</p>

        <hr />

        <!-- 4.2 -->
        <h3>4.2 Débutant+ → lecture de fichier (usage &amp; erreurs)</h3>
        <pre><code>// src/cat.vitl
module app.cat
import std.{fs, io, cli, str}

fn main() -&gt; i32 {
  let argv = cli::args()
  if str::len(argv) &lt; 2 {
    io::eprintln("usage: cat &lt;fichier&gt;")
    return 2 // erreur d'usage CLI
  }
  let path = argv[1]
  if !fs::exists(path) {
    io::eprintln("introuvable: " + path)
    return 3 // erreur I/O
  }
  let contenu = fs::read_to_string(path)? // propage l'erreur I/O si échec
  io::print(contenu)
  return 0
}
</code></pre>
        <p><strong>Exécution</strong> : <code>vitl run src/cat.vitl -- data.txt</code></p>
        <ul>
            <li>OK → affiche le contenu.</li>
            <li>Sans argument → sortie <strong>2</strong> (<em>erreur d’usage</em>).</li>
            <li>Fichier manquant → sortie <strong>3</strong> (<em>erreur I/O</em>).</li>
        </ul>
        <details>
            <summary>Extensions (comptez octets, multi-fichiers, chronométrage)</summary>
            <pre><code>// A) Taille en octets
module app.size
import std.{fs, io}
fn main()-&gt;i32 {
  let bytes = fs::read("data.bin")?
  io::println("taille=" + bytes.len().to_string() + " octets")
  return 0
}

// B) Multi-fichiers (ignore les manquants)
module app.cat_multi
import std.{fs, io, cli, str}
fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) &lt; 2 { io::eprintln("usage: cat_multi &lt;f1&gt; [&lt;f2&gt;...]"); return 2 }
  for i in 1..str::len(a) {
    let p = a[i]
    if !fs::exists(p) { io::eprintln("skip: " + p); continue }
    io::print(fs::read_to_string(p)?)
  }
  return 0
}

// C) Chronométrage simple
module app.timed_cat
import std.{fs, io, cli, str, time}
fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) != 2 { io::eprintln("usage: timed_cat &lt;f&gt;"); return 2 }
  let t0 = time::now()
  _ = fs::read_to_string(a[1])?
  io::println("ms=" + (time::now()-t0).to_string())
  return 0
}
</code></pre>
        </details>
        <div class="callout warn">
            <h4>Diagnostic enrichi (messages pédagogiques)</h4>
            <pre><code>let path = argv[1]
if !fs::exists(path) {
  io::eprintln("E2001: fichier introuvable → " + path)
  io::eprintln("Astuce: lancez depuis la racine du projet ou passez un chemin absolu.")
  return 3
}
</code></pre>
        </div>
        <h4>Tests</h4>
        <pre><code>// Exemple de test "attendu en erreur"
test "cat sans argument renvoie 2" {
  // pseudo-test illustratif : dans une vraie CI, on lance le binaire et on vérifie le code
  assert(2 == 2)
}
</code></pre>

        <hr />

        <!-- 4.3 -->
        <h3>4.3 Débutant++ → calculs et types (struct, méthodes, tests)</h3>
        <pre><code>// src/geom.vitl
module app.geom
import std.{io, math}

struct Vec2 { x: f64, y: f64 }

impl Vec2 {
  fn norm(&amp;self) -&gt; f64 { return (self.x*self.x + self.y*self.y).sqrt() }
  fn dot(&amp;self, o: Vec2) -&gt; f64 { return self.x*o.x + self.y*o.y }
}

fn main() -&gt; i32 {
  let v = Vec2 { x: 3.0, y: 4.0 }
  io::println(v.norm().to_string()) // 5
  return 0
}

// Tests intégrés
test "norme 3-4-5" {
  let v = Vec2 { x:3.0, y:4.0 }
  assert(v.norm() == 5.0)
}
test "produit scalaire orthogonal" {
  let a = Vec2 { x:1.0, y:0.0 }
  let b = Vec2 { x:0.0, y:1.0 }
  assert(a.dot(b) == 0.0)
}
</code></pre>
        <p><strong>Exécution</strong> : <code>vitl run src/geom.vitl</code> → affiche <code>5</code></p>
        <p><strong>Tests</strong> : <code>vitl test</code></p>

        <details>
            <summary>Variante : paramètres CLI &amp; parsing</summary>
            <pre><code>// src/geom_cli.vitl
module app.geom_cli
import std.{io, cli, str}

struct Vec2 { x:f64, y:f64 }
impl Vec2 { fn norm(&amp;self)-&gt;f64 { return (self.x*self.x + self.y*self.y).sqrt() } }

fn parse_f64(s:str) -&gt; Result&lt;f64,str&gt; { return str::to_float(s) }

fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) != 3 { io::eprintln("usage: geom_cli &lt;x&gt; &lt;y&gt;"); return 2 }
  let x = parse_f64(a[1])?
  let y = parse_f64(a[2])?
  let v = Vec2 { x:x, y:y }
  io::println(v.norm().to_string())
  return 0
}
</code></pre>
        </details>

        <hr />

        <!-- 4.4 -->
        <h3>4.4 Mini-projets guidés (copier / adapter)</h3>

        <h4>4.4.1 Greeter (salut personnalisé + validation)</h4>
        <pre><code>// src/greeter.vitl
module app.greeter
import std.{io, cli, str}

fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) != 2 { io::eprintln("usage: greeter &lt;nom&gt;"); return 2 }
  let name = a[1]
  if str::len(name) == 0 { io::eprintln("nom vide"); return 2 }
  io::println("Bonjour, " + name)
  return 0
}
</code></pre>
        <p><strong>Test manuel</strong> :
            <code>vitl run src/greeter.vitl -- Alice</code> → <code>Bonjour, Alice</code>
        </p>

        <h4>4.4.2 Compteur de lignes (LC) avec messages clairs</h4>
        <pre><code>// src/wc_lines.vitl
module app.wc_lines
import std.{io, fs, cli, str}

fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) != 2 { io::eprintln("usage: wc_lines &lt;fichier&gt;"); return 2 }
  let p = a[1]
  if !fs::exists(p) { io::eprintln("introuvable: " + p); return 3 }
  let txt = fs::read_to_string(p)?
  // Compte naïf des lignes : nombre de '\n' + 1 si non vide
  let mut n:i64 = 0
  for ch in &amp;txt {
    if ch == '\n' { n = n + 1 }
  }
  if str::len(txt) &gt; 0 &amp;&amp; txt[str::len(txt)-1] != '\n' { n = n + 1 }
  io::println(n.to_string())
  return 0
}
</code></pre>

        <h4>4.4.3 Mesure de temps &amp; micro-bench</h4>
        <pre><code>// src/bench.vitl
module app.bench
import std.{io, time}

fn heavy()-&gt;() {
  let mut s:i64 = 0
  for i in 0..100000 { s = s + i }
  io::println("acc=" + s.to_string())
}

fn main()-&gt;i32 {
  let t0 = time::now()
  heavy()
  io::println("ms=" + (time::now() - t0).to_string())
  return 0
}
</code></pre>

        <hr />

        <!-- 4.5 -->
        <h3>4.5 Gérer les erreurs proprement (Result, Option, messages)</h3>
        <pre><code>// src/config_load.vitl
module app.config_load
import std.{io, fs, str}

fn load_threshold(path:str) -&gt; Result&lt;i64, str&gt; {
  if !fs::exists(path) { return Result::Err("absent: " + path) }
  let s = fs::read_to_string(path)?
  // Nettoie un éventuel retour chariot / fin de ligne
  let cleaned = str::replace(str::replace(s, "\r", ""), "\n", "")
  return str::to_int(cleaned)
}

fn main()-&gt;i32 {
  match load_threshold("threshold.txt") {
    Result::Ok(v) =&gt; { io::println("seuil=" + v.to_string()); return 0 }
    Result::Err(e) =&gt; { io::eprintln("E: " + e); return 3 }
  }
}
</code></pre>

        <hr />

        <!-- 4.6 -->
        <h3>4.6 Modèle de projet minimal (à répliquer)</h3>
        <pre><code>mon_projet/
  src/
    main.vitl         // point d'entrée
    greeter.vitl      // sous-outil
    wc_lines.vitl     // sous-outil
  build/              // binaires
</code></pre>
        <pre><code>// src/main.vitl
module app.main
import std.io

fn main()-&gt;i32 {
  std.io::println("Projet prêt. Voir src/greeter.vitl et src/wc_lines.vitl")
  return 0
}
</code></pre>
        <p><strong>Formatez</strong> : <code>vitl fmt src/</code> · <strong>Testez</strong> : <code>vitl test</code> ·
            <strong>Compilez</strong> : <code>vitl build -O2 -o build/app src/main.vitl</code>
        </p>

        <hr />

        <!-- 4.7 -->
        <h3>4.7 Checklist mini-projet (qualité débutant → pro)</h3>
        <ul>
            <li>Un <code>main.vitl</code> exécutable en une commande.</li>
            <li>Messages d’erreur explicites (usage, I/O).</li>
            <li>Au moins 1–2 tests intégrés par fichier.</li>
            <li>Imports précis et formateur (<code>vitl fmt</code>) exécuté.</li>
            <li>Codes de sortie stables : 0 (OK) · 1 (panic) · 2 (usage) · 3 (I/O) · 4 (FFI).</li>
        </ul>

        <div class="card">
            <strong>Récap’ éclair (débutant)</strong>
            <ul>
                <li>Lancez vite avec <code>vitl run</code>, livrez rapide avec <code>vitl build</code>.</li>
                <li>Propagez les erreurs avec <code>?</code>, imprimez des messages utiles.</li>
                <li>Écrivez de petits tests : ils valent de la documentation exécutable.</li>
                <li>Structurez : un fichier = un module, noms clairs, imports groupés.</li>
            </ul>
        </div>
    </section>


    <!-- 5) MEMOIRE -->
    <section id="memoire">
        <h2>5) Mémoire et sécurité — ultra-guide débutant</h2>

        <div class="callout info">
            <h4>En clair (version simple)</h4>
            <ul>
                <li>Par défaut, vos variables vivent « toutes seules » (pile ou tas) et disparaissent quand elles
                    sortent du
                    scope.</li>
                <li>Quand plusieurs parties du code doivent partager la même donnée, utilisez des
                    <code>références comptées</code> : <code>Rc&lt;T&gt;</code>.
                </li>
                <li>Pour éviter les fuites quand deux objets se pointent « en rond » l’un l’autre, utilisez
                    <code>Weak&lt;T&gt;</code> pour le lien de retour.
                </li>
                <li>Le code « dangereux » (pointeurs bruts C, etc.) est isolé dans des blocs <code>unsafe</code> et
                    emballé
                    derrière une API sûre.</li>
            </ul>
        </div>

        <h3>5.1 Pourquoi parler de mémoire ?</h3>
        <p>Un programme manipule des valeurs (nombres, textes, tableaux…). Ces valeurs occupent de la mémoire. Deux
            grands
            risques : <em>utiliser de la mémoire libérée</em> (crashes, comportements bizarres) et <em>oublier de
                libérer</em> (fuites). VITL vous aide : il libère automatiquement quand plus personne n’utilise la
            donnée
            (comptage de références), et il encadre les appels « bas niveau » via FFI C.</p>

        <h3>5.2 Modèle mental (débutant)</h3>
        <ul>
            <li><strong>Valeur simple</strong> : « je possède la donnée » (ex. un <code>i32</code> ou une
                <code>String</code> locale).
            </li>
            <li><strong>Partage</strong> : « nous possédons à plusieurs » → enrobez la donnée dans un
                <code>Rc&lt;T&gt;</code>.
            </li>
            <li><strong>Lien de retour</strong> (parent ↔ enfant) : pour briser le cycle, le lien « faible » se fait en
                <code>Weak&lt;T&gt;</code>.
            </li>
            <li><strong>FFI</strong> : les chaînes C sont null-terminées ; on passe une <code>CString</code> et on
                respecte
                qui alloue/libère.</li>
        </ul>

        <h3>5.3 Références comptées : <code>Rc&lt;T&gt;</code></h3>
        <pre><code>import std.io

fn main() -&gt; i32 {
  let a = Rc&lt;i32&gt;::new(42) // 1 détenteur fort
  let b = a.clone()        // 2 détenteurs forts
  std.io::println("ok: " + (*b).to_string())
  a.drop()                 // 1 détenteur fort
  b.drop()                 // 0 → libération automatique
  return 0
}
</code></pre>
        <p><strong>Quand utiliser</strong> : configuration partagée, cache simple, nœuds d’arbre, tables consultées par
            plusieurs modules.</p>
        <div class="callout warn">
            <h4>À éviter</h4>
            <ul>
                <li>Tout mettre en <code>Rc</code> « par réflexe ». Une valeur locale simple suffit la plupart du temps.
                </li>
                <li>Créer des cycles forts (ex. parent → enfant et enfant → parent en <code>Rc</code> tous les deux).
                </li>
            </ul>
        </div>

        <h3>5.4 Lien faible : <code>Weak&lt;T&gt;</code> pour briser les cycles</h3>
        <p>Exemple classique : un parent garde ses enfants (fort), chaque enfant garde un lien vers son parent (faible).
        </p>
        <pre><code>// src/tree.vitl
module app.tree
import std.{io, str}

struct Node {
  name: String,
  parent: Weak&lt;Node&gt;,      // lien FAIBLE
  children: [Rc&lt;Node&gt;],     // liens FORTS
}

fn Node::new(name:str) -&gt; Rc&lt;Node&gt; {
  return Rc&lt;Node&gt;::new(Node { name: String::from(name), parent: Weak&lt;Node&gt;::new(), children: [] })
}

fn Node::add_child(this:&amp;Rc&lt;Node&gt;, child:Rc&lt;Node&gt;) -&gt; () {
  // le parent garde fort
  this.children.push(child.clone())
  // l'enfant garde FAIBLE vers le parent
  let w = Rc::downgrade(this)       // Rc -&gt; Weak
  child.parent.set(w)               // (API imagée : associer le Weak)
}

fn main()-&gt;i32 {
  let root = Node::new("root")
  let a = Node::new("A")
  Node::add_child(&amp;root, a)
  io::println("children=" + root.children.len().to_string())
  // On peut faire "upgrade" d'un Weak en Rc pour utiliser temporairement le parent
  match root.children[0].parent.upgrade() {
    Some(p) =&gt; io::println("parent de A = " + p.name),
    None    =&gt; io::println("parent libéré"),
  }
  return 0
}
</code></pre>
        <p><strong>Idée</strong> : si le parent meurt, le <code>Weak</code> devient « vide » (impossible à
            <code>upgrade()</code>), donc pas de fuite.
        </p>

        <h3>5.5 Chaînes : <code>str</code> (vue) vs <code>String</code> (tampon possédé)</h3>
        <ul>
            <li><code>str</code> : lecture sans copie (immuable). Idéal pour paramètres d’API.</li>
            <li><code>String</code> : vous possédez et pouvez modifier (ajouter, tronquer).</li>
        </ul>
        <pre><code>let s:str = "abc"
let mut buf = String::from("abc")
buf.push("d") // "abcd"
std.io::println(buf)
</code></pre>
        <div class="callout warn">
            <h4>Erreurs typiques</h4>
            <ul>
                <li>Conserver trop longtemps une vue sur une donnée qui n’existe plus.</li>
                <li>Construire une chaîne C depuis une <code>String</code> contenant <code>\0</code> (nul) : utilisez
                    <code>CString::from_str</code> qui valide.
                </li>
            </ul>
        </div>

        <h3>5.6 Collections &amp; slices (éviter les copies coûteuses)</h3>
        <pre><code>import std.{io, vec}
let mut v:[i32] = vec::with_capacity(16) // évite les réallocations
v.push(1); v.push(2); v.push(3)
for x in &amp;v { io::println(x.to_string()) } // itération par référence (pas de copie)
let third = v[2] // panique si hors bornes
</code></pre>
        <div class="callout warn">
            <h4>Attention aux pointeurs « invalidés »</h4>
            <p>Ne gardez pas un pointeur (ou une référence brute côté C) vers l’intérieur d’un vecteur si vous continuez
                à
                <code>push()</code> : une réallocation peut déplacer la mémoire.
            </p>
        </div>

        <h3>5.7 FFI C en sécurité (pont contrôlé)</h3>
        <p>Le C attend des <code>*const char</code> terminés par nul et ne comprend pas les <code>String</code> de VITL.
            Convertissez toujours via <code>CString</code>. Décidez qui libère quoi.</p>
        <pre><code>// Déclaration (ex.)
extern "C" { fn puts(msg:*const char) -&gt; i32 }

fn c_puts(s:str) -&gt; Result&lt;(), str&gt; {
  let c = std.c::CString::from_str(s)?   // valide l'absence de nul
  unsafe { _ = puts(c.as_ptr()) }        // frontière unsafe MINIMALE
  return Result::Ok(())
}
</code></pre>
        <ul>
            <li><strong>Frontière claire</strong> : convertir, vérifier, appeler C, <em>sortir</em> du
                <code>unsafe</code>
                rapidement.
            </li>
            <li><strong>Ownership documenté</strong> : si le C alloue, fournissez une fonction de libération claire
                (<code>free_c_buffer(ptr)</code>), et appelez-la côté VITL.</li>
        </ul>

        <h3>5.8 Libération automatique : quand ?</h3>
        <ul>
            <li>Variable locale : à la fin du bloc où elle est déclarée.</li>
            <li><code>Rc</code> : quand le compteur de références fortes retombe à zéro.</li>
            <li>Ressource externe (descripteur, handle C) : <em>vous</em> appelez explicitement la fonction de
                fermeture/libération prévue.</li>
        </ul>

        <h3>5.9 Petites recettes « zéro fuite »</h3>
        <ul>
            <li><strong>Graphes</strong> : liens « avant » en <code>Rc</code>, liens « retour » en <code>Weak</code>.
            </li>
            <li><strong>Caches</strong> : valeurs en <code>Rc</code>, index clé → <code>Weak</code> si vous voulez
                permettre
                l’éviction automatique.</li>
            <li><strong>FFI</strong> : 1) construire <code>CString</code> ; 2) appeler dans un petit <code>unsafe</code>
                ;
                3) libérer ce que le C a alloué, via la bonne fonction.</li>
        </ul>

        <h3>5.10 Diagnostic &amp; debug</h3>
        <ul>
            <li>Construire en debug : <code>vitl build -O0 -g -o build/app src/main.vitl</code> pour des messages plus
                précis.</li>
            <li>Messages clairs : incluez le chemin, l’action, la cause humaine (« Astuce : … »).</li>
            <li>Imprimez les tailles et compteurs (ex. <code>children.len()</code>) pour vérifier votre modèle.</li>
        </ul>
        <pre><code>// Message enrichi
let path = "data/config.txt"
if !std.fs::exists(path) {
  std.io::eprintln("E2001: fichier introuvable → " + path)
  std.io::eprintln("Astuce: lancez depuis la racine du projet ou passez un chemin absolu.")
  return 3
}
</code></pre>

        <h3>5.11 Mini-FAQ (débutant)</h3>
        <details>
            <summary>« Pourquoi <code>Weak</code> plutôt qu’un simple <code>Rc</code> ? »</summary>
            <p>Parce que deux <code>Rc</code> qui se référencent l’un l’autre ne tombent jamais à zéro → fuite.
                <code>Weak</code> n’augmente pas le compteur fort, donc la libération redevient possible.
            </p>
        </details>
        <details>
            <summary>« Je veux juste passer un texte à une fonction ; <code>str</code> ou <code>String</code> ? »
            </summary>
            <p>Si la fonction lit seulement, utilisez <code>str</code>. Si la fonction doit <em>conserver</em> et
                modifier
                plus tard, utilisez <code>String</code>.</p>
        </details>
        <details>
            <summary>« Puis-je garder un pointeur C vers un buffer VITL ? »</summary>
            <p>Évitez. Le C ne connaît pas les mouvements/redimensionnements. Copiez vers une zone gérée côté C, ou
                figez la
                durée de vie et documentez-la solidement.</p>
        </details>

        <h3>5.12 Exemples « prêt à copier »</h3>
        <h4>a) Partage simple sans cycle</h4>
        <pre><code>// src/shared_config.vitl
module app.shared_config
import std.{io}

struct Config { name:String, retries:i32 }

fn main()-&gt;i32 {
  let cfg = Rc&lt;Config&gt;::new(Config { name:String::from("demo"), retries:3 })
  let worker1 = cfg.clone()
  let worker2 = cfg.clone()
  io::println("retries=" + worker2.retries.to_string())
  // À la fin, worker1, worker2 et cfg tombent à 0 → libération
  return 0
}
</code></pre>

        <h4>b) Encapsuler une ressource C</h4>
        <pre><code>// src/ffi_wrapper.vitl
module app.ffi_wrapper
import std.{io, c}

// C opaque
extern "C" {
  fn obj_create() -&gt; *mut void
  fn obj_destroy(p:*mut void) -&gt; void
  fn obj_set_name(p:*mut void, name:*const char) -&gt; i32
}

struct Obj { handle:*mut void }

fn Obj::new() -&gt; Result&lt;Obj, str&gt; {
  let h = unsafe { obj_create() }
  if h == std.ptr::null_mut() { return Result::Err("ffi: create failed") }
  return Result::Ok(Obj{ handle:h })
}

fn Obj::set_name(&amp;mut self, name:str) -&gt; Result&lt;(), str&gt; {
  let cname = c::CString::from_str(name)?
  let rc = unsafe { obj_set_name(self.handle, cname.as_ptr()) }
  if rc != 0 { return Result::Err("ffi: set_name failed") }
  return Result::Ok(())
}

fn Obj::close(&amp;mut self) -&gt; () {
  if self.handle != std.ptr::null_mut() {
    unsafe { obj_destroy(self.handle) }
    self.handle = std.ptr::null_mut()
  }
}

fn main()-&gt;i32 {
  let mut o = Obj::new()?
  _ = o.set_name("demo")?
  o.close() // libération explicite
  return 0
}
</code></pre>

        <h3>5.13 Récapitulatif débutant</h3>
        <div class="card">
            <strong>Mémo</strong>
            <ul>
                <li><code>Rc</code> pour partager, <code>Weak</code> pour les liens retour.</li>
                <li><code>str</code> = vue de lecture, <code>String</code> = tampon possédé et modifiable.</li>
                <li>Ne passez pas de chaînes brutes au C : utilisez <code>CString</code>, isolez l’<code>unsafe</code>.
                </li>
                <li>Pré-allouez les vecteurs (ex. <code>vec::with_capacity</code>) et itérez par référence
                    (<code>&amp;v</code>).</li>
                <li>Messages d’erreur explicites et codes de sortie stables : 0 (OK) · 1 (panic) · 3 (I/O) · 4 (FFI).
                </li>
            </ul>
        </div>

        <div class="callout ok">
            <h4>Checklist « mémoire saine »</h4>
            <ul>
                <li>[ ] Ai-je vraiment besoin d’un <code>Rc</code> ici ?</li>
                <li>[ ] Existe-t-il un cycle potentiel ? Si oui, un lien doit être en <code>Weak</code>.</li>
                <li>[ ] Les buffers passés au C respectent-ils l’ABI (nul-terminé, durée de vie contrôlée) ?</li>
                <li>[ ] Ai-je fermé/détruit toutes les ressources externes (fichiers, handles C) ?</li>
                <li>[ ] Les messages d’erreur expliquent-ils quoi faire ?</li>
            </ul>
        </div>
    </section>


    <hr />

    <!-- 6) ERREURS -->
    <section id="erreurs">
        <h2>6) Gestion des erreurs — ultra-guide débutant</h2>

        <div class="callout info">
            <h4>À retenir en 30 secondes</h4>
            <ul>
                <li><strong>Tout ce qui peut échouer</strong> retourne <code>Result&lt;T,E&gt;</code> (succès
                    <code>Ok(T)</code> / échec <code>Err(E)</code>).
                </li>
                <li>L’opérateur <code>?</code> <em>propage</em> automatiquement l’erreur vers l’appelant (écrit moins,
                    gère
                    mieux).</li>
                <li><code>Option&lt;T&gt;</code> signifie « peut être absent » : <code>Some(T)</code> ou
                    <code>None</code>.
                </li>
                <li><code>panic("message")</code> = arrêt immédiat (réservé à l’irréparable : invariants brisés,
                    corruption).
                </li>
                <li>Mappez vos erreurs vers des <strong>codes de sortie</strong> stables : 0 OK · 1 panic · 2 usage CLI
                    · 3
                    I/O · 4 FFI.</li>
            </ul>
        </div>

        <h3>6.1 Pourquoi gérer les erreurs ?</h3>
        <p>Une bonne gestion d’erreurs rend votre outil <em>prévisible</em> et <em>aimable</em> : message clair, action
            proposée, code de sortie stable (pour les scripts/CI). VITL favorise l’approche <strong>explicite</strong> :
            on
            retourne un <code>Result</code> (ou <code>Option</code>) au lieu de masquer l’échec.</p>

        <h3>6.2 Le type <code>Result&lt;T,E&gt;</code> (base)</h3>
        <pre><code>import std.{io, fs}

// Lecture de fichier : renvoie le texte ou une erreur (str)
fn read_cfg(path: str) -&gt; Result&lt;str, str&gt; {
  if !fs::exists(path) {
    return Result::Err("absent: " + path)
  }
  let txt = fs::read_to_string(path)?   // propage l'erreur I/O si lecture échoue
  return Result::Ok(txt)
}

// Consommation : pattern matching
fn main() -&gt; i32 {
  match read_cfg("config.txt") {
    Result::Ok(txt) =&gt; io::println(txt),
    Result::Err(e)  =&gt; { io::eprintln("E: " + e); return 3 }
  }
  return 0
}
</code></pre>
        <p><strong>Astuce</strong> — Commencez par une version « simple » où <code>E</code> est une chaîne
            <code>str</code>. Plus tard, passez à un type d’erreur structuré (cf. §6.9).
        </p>

        <h3>6.3 L’opérateur <code>?</code> (propagation automatique)</h3>
        <p><code>?</code> ne marche que dans une fonction qui <em>retourne</em> un <code>Result&lt;...&gt;</code>. Si
            l’expression à droite retourne <code>Err</code>, la fonction <em>renvoie immédiatement</em> cette erreur.
        </p>
        <pre><code>import std.{fs}

fn load_or_err(path: str) -&gt; Result&lt;str, str&gt; {
  // Vérif claire + propagation compacte
  if !fs::exists(path) { return Result::Err("introuvable: " + path) }
  let txt = fs::read_to_string(path)?  // &lt;= ici `?` propage l'erreur I/O
  return Result::Ok(txt)
}
</code></pre>

        <div class="callout ok">
            <h4>Bon motif (garde précoce)</h4>
            <p>Validez tôt, échouez tôt avec un message actionnable. Cela évite les cascades d’erreurs plus loin.</p>
        </div>

        <h3>6.4 <code>Option&lt;T&gt;</code> : absence de valeur ≠ erreur</h3>
        <pre><code>import std.{io, cli}

fn print_home() -&gt; () {
  match cli::env("HOME") {
    Some(h) =&gt; io::println(h),
    None    =&gt; io::eprintln("HOME non défini")
  }
}
</code></pre>
        <p>Utilisez <code>Option</code> quand l’absence est <em>attendue</em> (ex. variable d’environnement
            facultative).
            Utilisez <code>Result</code> quand c’est une <em>erreur</em>.</p>

        <h3>6.5 Messages clairs : quoi / où / comment agir</h3>
        <pre><code>// Mauvais : vague
io::eprintln("échec")

// Meilleur : contexte + astuce
io::eprintln("E2001: fichier introuvable → " + path)
io::eprintln("Astuce: lancez depuis la racine du projet ou passez un chemin absolu.")
</code></pre>

        <h3>6.6 Codes de sortie (stables)</h3>
        <ul>
            <li><strong>0</strong> succès</li>
            <li><strong>1</strong> erreur générique / panic</li>
            <li><strong>2</strong> erreur d’usage CLI (arguments invalides/manquants)</li>
            <li><strong>3</strong> erreurs I/O (fichiers, permissions, disque)</li>
            <li><strong>4</strong> erreurs FFI (appel C, contrat ABI)</li>
        </ul>

        <h3>6.7 Schéma recommandé pour <code>main()</code></h3>
        <pre><code>import std.{io, str, cli, fs}

// 1) "run" fait le travail et renvoie Result
fn run() -&gt; Result&lt;(), str&gt; {
  let args = cli::args()
  if str::len(args) &lt; 2 {
    return Result::Err("USAGE: app &lt;fichier&gt; (code 2)")
  }
  let path = args[1]
  if !fs::exists(path) { return Result::Err("E2001: absent → " + path) }
  io::print(fs::read_to_string(path)?)  // ? propage l'I/O
  return Result::Ok(())
}

// 2) "main" mappe proprement vers un code de sortie
fn main() -&gt; i32 {
  match run() {
    Result::Ok(()) =&gt; return 0,
    Result::Err(msg) =&gt; {
      io::eprintln(msg)
      // Petite heuristique pour l'exemple :
      if str::find(msg, "USAGE:") != -1 { return 2 }
      if str::find(msg, "E2001") != -1 { return 3 }
      return 1
    }
  }
}
</code></pre>

        <h3>6.8 Validation d’entrée (avant l’I/O)</h3>
        <pre><code>import std.{io, str}

fn parse_port(s: str) -&gt; Result&lt;i32, str&gt; {
  match str::to_int(s) {
    Result::Ok(n) =&gt; {
      if n &lt; 1 || n &gt; 65535 { return Result::Err("port hors plage (1..65535)") }
      return Result::Ok(n as i32)
    }
    Result::Err(_) =&gt; return Result::Err("port invalide: " + s)
  }
}
</code></pre>

        <h3>6.9 Aller plus loin : erreurs structurées</h3>
        <p>Pour les applis plus grandes, définissez un <em>type d’erreur</em> unique. Exemple avec un <code>enum</code>
            et
            un <code>to_msg()</code> :</p>
        <pre><code>import std.{io, fs, str}

enum AppErr {
  Usage(str),   // USAGE/validation
  Io(str),      // fichiers/disque
  Parse(str),   // conversion/format
  Ffi(str),     // pont C
  Other(str),
}

fn err_usage(m:str) -&gt; AppErr { return AppErr::Usage(m) }
fn err_io(m:str)    -&gt; AppErr { return AppErr::Io(m) }
fn err_parse(m:str) -&gt; AppErr { return AppErr::Parse(m) }
fn err_ffi(m:str)   -&gt; AppErr { return AppErr::Ffi(m) }
fn err_other(m:str) -&gt; AppErr { return AppErr::Other(m) }

fn to_msg(e:AppErr) -&gt; str {
  match e {
    AppErr::Usage(m) =&gt; return "USAGE: " + m,
    AppErr::Io(m)    =&gt; return "I/O: " + m,
    AppErr::Parse(m) =&gt; return "PARSE: " + m,
    AppErr::Ffi(m)   =&gt; return "FFI: " + m,
    AppErr::Other(m) =&gt; return "ERR: " + m,
  }
}

// Mapping type d'erreur -&gt; code de sortie
fn to_exit(e:AppErr) -&gt; i32 {
  match e {
    AppErr::Usage(_) =&gt; return 2,
    AppErr::Io(_)    =&gt; return 3,
    AppErr::Ffi(_)   =&gt; return 4,
    _                =&gt; return 1,
  }
}

fn load_cfg(path:str) -&gt; Result&lt;str, AppErr&gt; {
  if !fs::exists(path) { return Result::Err(err_io("absent: " + path)) }
  match fs::read_to_string(path) {
    Result::Ok(t) =&gt; return Result::Ok(t),
    Result::Err(e)&nbsp;=&gt; return Result::Err(err_io(e)),  // on ré-étiquette I/O
  }
}

fn run() -&gt; Result&lt;(), AppErr&gt; {
  let a = std.cli::args()
  if str::len(a) != 2 { return Result::Err(err_usage("app &lt;fichier&gt;")) }
  let txt = load_cfg(a[1])?
  io::println(txt)
  return Result::Ok(())
}

fn main()-&gt;i32 {
  match run() {
    Result::Ok(())  =&gt; return 0,
    Result::Err(e)  =&gt; { io::eprintln(to_msg(e)); return to_exit(e) }
  }
}
</code></pre>

        <h3>6.10 FFI : convertir et relayer proprement</h3>
        <pre><code>extern "C" { fn foo_do(p:*const char) -&gt; i32 } // 0 = OK, &lt;0 = erreur
import std.{c}

fn foo_call(s:str) -&gt; Result&lt;(), AppErr&gt; {
  let cs = c::CString::from_str(s)?           // si nul interne: Err(...) auto
  let rc = unsafe { foo_do(cs.as_ptr()) }
  if rc &lt; 0 { return Result::Err(err_ffi("foo_do rc=" + rc.to_string())) }
  return Result::Ok(())
}
</code></pre>

        <h3>6.11 Tests d’erreurs (unitaires)</h3>
        <pre><code>test "parse_port rejette 0" {
  match parse_port("0") {
    Result::Ok(_)   =&gt; assert(false),  // ne devrait pas arriver
    Result::Err(m)  =&gt; assert(m == "port hors plage (1..65535)")
  }
}
</code></pre>

        <h3>6.12 Écrire moins, expliquer plus (gabarits « prêt à copier »)</h3>
        <h4>a) Lecture de fichier conviviale</h4>
        <pre><code>fn show(path:str) -&gt; Result&lt;(), str&gt; {
  if !std.fs::exists(path) {
    return Result::Err("E2001: fichier introuvable → " + path + "\nAstuce: passez un chemin absolu.")
  }
  std.io::print(std.fs::read_to_string(path)?)
  return Result::Ok(())
}
</code></pre>

        <h4>b) Chaînage d’étapes avec <code>?</code></h4>
        <pre><code>fn pipeline(p:str) -&gt; Result&lt;(), str&gt; {
  let raw = std.fs::read_to_string(p)?        // 1) I/O
  let cleaned = std.str::replace(raw, "\r\n", "\n")
  let n = std.str::to_int(cleaned)?           // 2) parse
  if n &lt;= 0 { return Result::Err("valeur non positive") }
  std.io::println("ok:" + n.to_string())      // 3) ok
  return Result::Ok(())
}
</code></pre>

        <h3>6.13 Panic : cas limites uniquement</h3>
        <pre><code>// Invariant interne brisé: continuer serait dangereux
fn expect_even(n:i32) -&gt; () {
  if n % 2 != 0 { panic("invariant: pair attendu, reçu " + n.to_string()) }
}
</code></pre>
        <div class="callout warn">
            <h4>À proscrire en prod</h4>
            <p>Ne « paniquez » pas pour des erreurs d’utilisateur (fichier manquant, mauvais argument). Préférez
                <code>Result</code> + message + code de sortie.
            </p>
        </div>

        <h3>6.14 Mini-FAQ débutant</h3>
        <details>
            <summary>« Pourquoi <code>?</code> ne marche pas dans <code>main()</code> ? »</summary>
            <p>Parce que <code>main()</code> retourne un <code>i32</code>, pas un <code>Result</code>. Placez le
                <code>?</code> dans une fonction <code>run() -&gt; Result&lt;...&gt;</code>, puis faites le mapping dans
                <code>main()</code>.
            </p>
        </details>
        <details>
            <summary>« <code>Option</code> ou <code>Result</code> ? »</summary>
            <p><code>Option</code> si l’absence est normale (clé facultative). <code>Result</code> si c’est inattendu
                (erreur d’I/O, format).</p>
        </details>
        <details>
            <summary>« Comment ajouter du contexte à une erreur ? »</summary>
            <p>Préfixez le message avec la tâche en cours et l’élément fautif : <code>"parse seuil: " + e</code>,
                <code>"ouvrir " + path + ": " + e</code>.
            </p>
        </details>

        <h3>6.15 Récapitulatif</h3>
        <div class="card">
            <strong>Mémo</strong>
            <ul>
                <li><code>Result</code> partout où ça peut échouer ; <code>?</code> pour propager.</li>
                <li><code>Option</code> pour l’absence prévue ; <code>panic</code> pour l’irréparable seulement.</li>
                <li>Messages utiles = <em>quoi</em> + <em>où</em> + <em>comment agir</em>.</li>
                <li>Codes de sortie stables (0/1/2/3/4) = outillage CI heureux.</li>
                <li>En grand projet : un type d’erreur unique + mapping → code de sortie.</li>
            </ul>
        </div>

        <div class="callout ok">
            <h4>Checklist « erreurs propres »</h4>
            <ul>
                <li>[ ] Chaque source d’échec retourne un <code>Result</code> documenté.</li>
                <li>[ ] <code>run()</code> centralise la logique et <code>main()</code> mappe vers un code.</li>
                <li>[ ] Messages d’erreur concis + astuce d’action.</li>
                <li>[ ] Pas de <code>panic</code> pour l’input utilisateur.</li>
                <li>[ ] Tests incluant des chemins d’échec (I/O, parse, FFI).</li>
            </ul>
        </div>

        <!-- Extraits de base (rappel) -->
        <pre><code>let contenu = std.fs::read_to_string("config.txt")?

match std.fs::read_to_string("config.txt") {
  Result::Ok(txt) =&gt; std.io::println(txt),
  Result::Err(e)  =&gt; std.io::eprintln(e),
}
</code></pre>
    </section>


    <hr />

    <!-- 7) FFI -->
    <section id="ffi">
        <h2>7) Interopérabilité C (FFI) — ultra-guide débutant (et au-delà)</h2>

        <div class="callout info">
            <h4>Pourquoi le FFI&nbsp;?</h4>
            <p>Le FFI (Foreign Function Interface) permet à un programme VITL d’appeler du <strong>code C
                    existant</strong>
                (librairies système, libs tierces, moteurs natifs). On réutilise ainsi des décennies d’APIs sans tout
                réécrire.</p>
            <ul>
                <li><strong>Cas d’usage</strong> : compression (zlib), bases de données (SQLite), cryptographie
                    (OpenSSL),
                    GUI, accélération SIMD.</li>
                <li><strong>Principe</strong> : décrire les fonctions C en <code>extern "C"</code>, convertir les
                    données
                    (chaînes, buffers), et respecter les règles d’ownership (qui alloue/libère&nbsp;?).</li>
            </ul>
        </div>

        <div class="callout warn">
            <h4>Checklist sécurité FFI (imprimez-moi)</h4>
            <ul>
                <li>Toujours appeler le C dans un bloc <code>unsafe</code> <em>isolé</em> (enveloppez dans une fonction
                    VITL
                    «&nbsp;safe&nbsp;»).</li>
                <li>Chaînes VITL → C&nbsp;: utilisez <code>std.c::CString::from_str</code> (refuse les <code>\0</code>
                    internes) et gardez la valeur en vie pendant l’appel.</li>
                <li>Chaînes/buffers C → VITL&nbsp;: <strong>copiez</strong> les données côté VITL puis libérez avec la
                    bonne
                    fonction (souvent <code>std.c::free</code> fournie par le C).</li>
                <li>Définissez clairement <em>qui alloue / qui libère</em>, et avec <em>quel allocateur</em>.</li>
                <li>N’utilisez que des types C stables&nbsp;: <code>int32_t</code>, <code>uint8_t</code>,
                    <code>size_t</code>,
                    <code>double</code>. Évitez <code>long</code>.
                </li>
                <li>Préférez des <strong>handles opaques</strong> (pointeurs non déréférencés) + méthodes
                    <code>new</code>/<code>close</code>.
                </li>
                <li>Chaque appel C retourne un code → mappez en <code>Result</code> et <em>n’ignorez jamais</em> un code
                    d’erreur.</li>
            </ul>
        </div>

        <h3>7.1 Vocabulaire express</h3>
        <ul>
            <li><strong>ABI C</strong> : convention d’appel binaire partagée (même empilement, même nommage), nécessaire
                pour se comprendre à l’exécution.</li>
            <li><strong>Opaque</strong> : on manipule un <code>*mut void</code> côté VITL sans connaître la structure
                interne (définie en C).</li>
            <li><strong>Ownership</strong> : qui possède la mémoire&nbsp;? Celui qui alloue doit libérer, <em>avec le
                    même
                    allocateur</em>.</li>
        </ul>

        <h3>7.2 Premier appel C (chaîne VITL → C)</h3>
        <pre><code>import std.{io, c}

// Déclaration d'une fonction C : int puts(const char*);
extern "C" { fn puts(msg:*const char) -&gt; i32 }

fn main() -&gt; i32 {
  let cs = c::CString::from_str("Hello C!\n")?   // valide, pas de '\0' interne
  unsafe { _ = puts(cs.as_ptr()) }               // appel dans `unsafe`
  return 0
}
</code></pre>

        <h3>7.3 Chaînes C → VITL (qui libère ?)</h3>
        <p>De nombreuses libs C renvoient un <code>char*</code> <em>allocé par elles</em>. La règle est&nbsp;: on
            <strong>copie</strong> côté VITL, puis on libère avec <code>free()</code> (ou une fonction dédiée).
        </p>
        <pre><code>// C (entête côté .h)
// char* make_msg();           // alloue (malloc)
// void  free_msg(char* p);    // libère

extern "C" {
  fn make_msg() -&gt; *mut char
  fn free_msg(p:*mut char) -&gt; void
}

fn get_message() -&gt; Result&lt;String, str&gt; {
  let p = unsafe { make_msg() }
  if p == std.ptr::null_mut() { return Result::Err("ffi: make_msg a renvoyé NULL") }

  // Copier le contenu C-&gt;VITL puis libérer côté C
  let s = std.c::copy_cstring_into_string(p)?   // &lt;= utilitaire (copie jusqu'au '\0')
  unsafe { free_msg(p) }
  return Result::Ok(s)
}
</code></pre>
        <p><em>Variante</em> : si la lib documente « utilisez <code>free()</code> standard », exposez
            <code>extern "C" { fn free(p:*mut void) -&gt; void }</code> et appelez-la, pas un <code>delete</code>
            maison.
        </p>

        <h3>7.4 Buffers binaires (pointeur + longueur)</h3>
        <p>Motif courant&nbsp;: passer un bloc mémoire à C et recevoir des octets en sortie.</p>
        <pre><code>// C
// int sha256(const uint8_t* data, size_t len, uint8_t* out32); // 0=OK

extern "C" { fn sha256(data:*const u8, len:usize, out:*mut u8) -&gt; i32 }

fn hash256(input:[u8]) -&gt; Result&lt;[u8;32], str&gt; {
  let mut out:[u8;32] = [0; 32]
  let rc = unsafe { sha256(input.as_ptr(), input.len(), out.as_mut_ptr()) }
  if rc != 0 { return Result::Err("ffi: sha256 rc=" + rc.to_string()) }
  return Result::Ok(out)
}
</code></pre>

        <h3>7.5 Handles opaques (pattern recommandé)</h3>
        <p>Exposez une poignée opaque et des fonctions d’usine/destruction côté C, puis encapsulez en VITL.</p>
        <pre><code>// C (shim)
// typedef struct Foo Foo;
// Foo* foo_create(int cap); void foo_destroy(Foo*);
// int   foo_push(Foo*, const char*); int foo_len(const Foo*);

extern "C" {
  fn foo_create(cap:i32)   -&gt; *mut void
  fn foo_destroy(h:*mut void) -&gt; void
  fn foo_push(h:*mut void, s:*const char) -&gt; i32
  fn foo_len(h:*const void) -&gt; i32
}

struct Foo { handle:*mut void }

impl Foo {
  fn new(cap:i32) -&gt; Result&lt;Foo,str&gt; {
    let h = unsafe { foo_create(cap) }
    if h == std.ptr::null_mut() { return Result::Err("ffi: create failed") }
    return Result::Ok(Foo{ handle:h })
  }
  fn push(&amp;mut self, s:str) -&gt; Result&lt;(),str&gt; {
    let cs = std.c::CString::from_str(s)?
    let rc = unsafe { foo_push(self.handle, cs.as_ptr()) }
    if rc != 0 { return Result::Err("ffi: push rc=" + rc.to_string()) }
    return Result::Ok(())
  }
  fn len(&amp;self) -&gt; i32 { return unsafe { foo_len(self.handle) } }
  fn close(&amp;mut self) -&gt; () {
    if self.handle != std.ptr::null_mut() {
      unsafe { foo_destroy(self.handle) }
      self.handle = std.ptr::null_mut()
    }
  }
}
</code></pre>
        <p><strong>Discipline</strong> : un seul endroit «&nbsp;unsafe&nbsp;» par méthode, vérifications avant/après
            (NULL, codes).</p>

        <h3>7.6 Ownership &amp; allocation — 3 règles d’or</h3>
        <ol>
            <li>Celui qui <em>alloue</em> <strong>libère</strong> (avec la même famille d’allocateurs).</li>
            <li><em>Copiez</em> de C vers VITL si vous voulez conserver la donnée après l’appel.</li>
            <li>Pas de pointeur C vers une donnée VITL <em>temporaire</em> (durée de vie insuffisante).</li>
        </ol>

        <h3>7.7 Cartographier les erreurs C → <code>Result</code></h3>
        <pre><code>fn c_ok(rc:i32) -&gt; Result&lt;(), str&gt; {
  if rc == 0 { return Result::Ok(()) }
  return Result::Err("ffi: rc=" + rc.to_string())
}
</code></pre>

        <h3>7.8 Liens &amp; édition (build)</h3>
        <p>Nom des bibliothèques&nbsp;: <code>libfoo.so</code> (Linux), <code>libfoo.dylib</code> (macOS),
            <code>foo.dll</code> (Windows).
        </p>
        <pre><code># Linux/macOS (bibliothèque partagée)
vitl build -O2 -L libs -lfoo -o build/app src/main.vitl

# rpath (trouver la lib au runtime)
vitl build ... -Wl,-rpath,$ORIGIN/../libs

# Statique (si libfoo.a disponible)
vitl build -O3 -L libs -Wl,-Bstatic -lfoo -Wl,-Bdynamic -o build/app src/main.vitl

# Windows (MinGW, exemple)
vitl build -O2 -L libs -lfoo -o build/app.exe src/main.vitl
</code></pre>

        <h3>7.9 En-têtes C « propres »</h3>
        <pre><code>// foo.h
#pragma once
#include &lt;stddef.h&gt;   // size_t
#include &lt;stdint.h&gt;   // int32_t, uint8_t

#ifdef __cplusplus
extern "C" {
#endif

typedef struct Foo Foo;
Foo*  foo_create(int32_t cap);
void  foo_destroy(Foo*);
int32_t foo_push(Foo*, const char* s);     // s: NUL-terminée, UTF-8
int32_t foo_len(const Foo*);

#ifdef __cplusplus
}
#endif
</code></pre>
        <p><em>Note</em> : documentez « qui libère quoi » et la null-termination des chaînes.</p>

        <h3>7.10 Callbacks &amp; <code>user_data</code></h3>
        <p>Beaucoup d’APIs C vous rappellent via une fonction. Passez un identifiant opaque et rassemblez la logique
            côté
            C si possible.</p>
        <pre><code>// C
// typedef void (*on_item_fn)(const char* s, void* user);
// int enumerate(on_item_fn cb, void* user);

extern "C" { fn enumerate(cb:*const void, user:*mut void) -&gt; i32 }

// Côté VITL, préférez écrire un petit shim C si vous devez capturer de l'état.
// Sinon, passez un identifiant (index) et rangez l'état dans une table VITL.
</code></pre>

        <h3>7.11 Tests d’intégration FFI</h3>
        <ul>
            <li>Test «&nbsp;happy path&nbsp;» (rc=0), test d’échec (rc&lt;0).</li>
            <li>Fuite mémoire&nbsp;: bouclez des <code>create</code>/<code>destroy</code>, surveillez la conso.</li>
            <li>Longueurs/limites&nbsp;: buffers exacts, off-by-one, <code>NULL</code>.</li>
        </ul>

        <h3>7.12 Mini-FAQ débutant</h3>
        <details>
            <summary>« Puis-je passer une <code>String</code> VITL directement au C ? »</summary>
            <p>Non. Convertissez en <code>CString</code> (NUL-terminée), conservez-la vivante pendant l’appel, puis
                laissez
                VITL la libérer.</p>
        </details>
        <details>
            <summary>« La lib C me donne un <code>char*</code>. Je fais quoi ? »</summary>
            <p>Copiez dans une <code>String</code> VITL, puis libérez le <code>char*</code> avec la fonction fournie
                (<code>free_msg</code> ou <code>free</code> documenté).</p>
        </details>
        <details>
            <summary>« Pourquoi <code>unsafe</code> ? »</summary>
            <p>Parce que VITL ne peut pas vérifier la validité des pointeurs/tailles C. Isolez l’<code>unsafe</code>
                dans
                des wrappers courts et testés.</p>
        </details>

        <h3>7.13 Mémo final</h3>
        <div class="card">
            <strong>À mémoriser</strong>
            <ul>
                <li>Déclarer en <code>extern "C"</code>, appeler dans <code>unsafe</code>, envelopper dans une API VITL
                    « safe
                    ».</li>
                <li>Chaînes&nbsp;: <code>CString</code> pour passer au C ; copier (&amp; libérer C) pour revenir.</li>
                <li>Buffers&nbsp;: <code>ptr + len</code> ; vérifier les tailles ; gérer le code retour.</li>
                <li>Handles opaques&nbsp;: <code>new</code>/<code>close</code>, pas de déréférencement côté VITL.</li>
                <li>Build&nbsp;: <code>-L</code> et <code>-l</code>, éventuellement <code>rpath</code> ; noms de libs
                    selon
                    l’OS.</li>
            </ul>
        </div>

        <!-- Extrait minimal (rappel) -->
        <pre><code>extern "C" { fn puts(msg:*const char) -&gt; i32 }
let cstr = std.c::CString::from_str("Hello C!\n")?
unsafe { _ = puts(cstr.as_ptr()) }
</code></pre>
    </section>


    <hr />

    <!-- 8) STDLIB -->
    <section id="stdlib">
        <h2>8) Stdlib — ultra-guide débutant (et utile aux pros)</h2>

        <div class="callout info">
            <h4>À quoi sert la stdlib&nbsp;?</h4>
            <p>La <strong>bibliothèque standard</strong> (stdlib) regroupe des modules prêts à l’emploi pour les tâches
                courantes&nbsp;: afficher du texte, lire/écrire des fichiers, manipuler les chaînes et vecteurs, mesurer
                le
                temps, accéder aux arguments de la ligne de commande, intéragir avec le C, etc.</p>
            <ul>
                <li>Tout est <strong>nommé</strong> <code>std.&lt;module&gt;</code> (ex.&nbsp;<code>std.fs</code>).</li>
                <li>Les appels système qui peuvent échouer retournent un <code>Result&lt;...&gt;</code> → utilisez
                    <code>?</code> pour propager.
                </li>
                <li>Les fonctions sont conçues pour être <strong>prévisibles</strong> et <strong>faciles à
                        lire</strong>.</li>
            </ul>
        </div>

        <div class="card">
            <strong>Carte mentale</strong>
            <ul>
                <li><strong>I/O console</strong> → <code>std.io</code></li>
                <li><strong>Fichiers/chemins</strong> → <code>std.fs</code></li>
                <li><strong>Chaînes</strong> → <code>std.str</code></li>
                <li><strong>Maths</strong> → <code>std.math</code></li>
                <li><strong>Temps</strong> → <code>std.time</code></li>
                <li><strong>Arguments/env</strong> → <code>std.cli</code></li>
                <li><strong>Vecteurs</strong> → <code>std.vec</code></li>
                <li><strong>Debug/assert</strong> → <code>std.debug</code></li>
                <li><strong>Erreurs structurées</strong> → <code>std.err</code></li>
                <li><strong>Pont C</strong> → <code>std.c</code></li>
            </ul>
        </div>

        <h3>8.1 <code>std.io</code> — Entrées/sorties console</h3>
        <p><em>But</em> : écrire sur la sortie standard (utilisateur) et la sortie d’erreur (diagnostics).</p>
        <pre><code>import std.io

io::print("Hello ")          // sans saut de ligne
io::println("world")         // avec saut de ligne
io::eprintln("attention!")   // sur STDERR
</code></pre>
        <ul>
            <li><strong>Quand utiliser STDERR&nbsp;?</strong> Pour les messages d’erreur/diagnostic afin de ne pas «
                polluer
                » la sortie normale (utile en pipelines).</li>
            <li><strong>Astuce débutant</strong>&nbsp;: préférez <code>println</code> pour avoir automatiquement le
                retour à
                la ligne.</li>
        </ul>

        <h3>8.2 <code>std.fs</code> — Fichiers et chemins</h3>
        <p><em>But</em> : lire/écrire des fichiers texte ou binaires, tester l’existence.</p>
        <pre><code>import std.{fs, io}

// Lire tout un fichier en chaîne (UTF-8)
let txt = fs::read_to_string("input.txt")?   // &lt;= `?` propage l'erreur I/O
io::println("lu=" + txt)

// Écrire une chaîne (écrase si existe)
_ = fs::write_string("out.txt", "ok\n")?

// Lire binaire
let bytes = fs::read("image.bin")?
io::println("taille=" + bytes.len().to_string())

// Vérifier l'existence avant d'ouvrir
if !fs::exists("config.toml") {
  io::eprintln("absent: config.toml")
  // retourner un code 3 (I/O) dans `main` si approprié
}
</code></pre>
        <div class="callout warn">
            <h4>Pièges</h4>
            <ul>
                <li>Fichier absent → ne paniquez pas&nbsp;: testez <code>exists</code> ou gérez l’erreur renvoyée par
                    <code>read*</code>.
                </li>
                <li>Chemins relatifs → dépendent du dossier courant (souvent la racine du projet en dev, pas forcément
                    en
                    prod).</li>
            </ul>
        </div>

        <h3>8.3 <code>std.str</code> — Chaînes et utilitaires</h3>
        <p><em>But</em> : opérations usuelles sur les chaînes de caractères (UTF-8).</p>
        <pre><code>import std.{str, io}

let s = "a b c"
io::println(str::len(s).to_string())         // 5
let parts = str::split(s, ' ')               // ["a","b","c"]
let i = str::find("abc", "b")                // 1
let out = str::replace("a_b", "_", "-")      // "a-b"

// Parsing vers nombres (renvoie Result)
let n = str::to_int("42")?     // i64
let f = str::to_float("2.5")?  // f64
</code></pre>
        <ul>
            <li><strong>Rappel concat</strong> : convertissez les nombres&nbsp;→ <code>"n=" + n.to_string()</code>.</li>
            <li><strong>Robustesse</strong> : mettez <code>? </code> sur <code>to_int</code>/<code>to_float</code>
                (entrée
                utilisateur imprévisible).</li>
        </ul>

        <h3>8.4 <code>std.math</code> — Maths</h3>
        <pre><code>import std.{math, io}

let d = math::sqrt(3.0*3.0 + 4.0*4.0) // 5.0
let a = math::abs(-12)                 // 12
io::println(d.to_string())
</code></pre>

        <h3>8.5 <code>std.time</code> — Horloge &amp; mesure</h3>
        <p><em>But</em> : mesurer un temps d’exécution, estampiller un événement.</p>
        <pre><code>import std.{time, io}

let t0 = time::now()
heavy_work()
io::println("ms=" + (time::now() - t0).to_string())
</code></pre>
        <ul>
            <li><strong>Astuce</strong> : encapsulez la mesure dans une petite fonction réutilisable (voir « patrons »
                plus
                bas).</li>
        </ul>

        <h3>8.6 <code>std.cli</code> — Arguments et variables d’environnement</h3>
        <pre><code>import std.{cli, io, str}

let argv = cli::args()
if str::len(argv) &lt; 2 {
  io::eprintln("usage: app &lt;fichier&gt;")
  // return 2 dans `main` (erreur d'usage)
}

// Variables d'environnement
match cli::env("HOME") {
  Some(h) =&gt; io::println(h),
  None    =&gt; io::eprintln("HOME non défini"),
}
</code></pre>
        <div class="callout ok">
            <h4>Bons réflexes</h4>
            <ul>
                <li>Vérifiez le <strong>nombre d’arguments</strong> et affichez un message d’usage clair.</li>
                <li>Mappez les erreurs d’usage sur le <strong>code 2</strong> (voir « Codes de sortie »).</li>
            </ul>
        </div>

        <h3>8.7 <code>std.vec</code> — Vecteurs dynamiques</h3>
        <p><em>But</em> : gérer des tableaux extensibles de valeurs.</p>
        <pre><code>import std.{vec, io}

let mut v:[i32] = vec::with_capacity(16)
v.push(1); v.push(2); v.push(3)
for x in &amp;v { io::println(x.to_string()) }   // itération par référence (pas de copie)

match v.pop() {
  Some(last) =&gt; io::println("last=" + last.to_string()),
  None       =&gt; {}
}
io::println("len=" + v.len().to_string())
</code></pre>
        <div class="callout warn">
            <h4>Piège</h4>
            <p>L’accès <code>v[i]</code> vérifie les bornes et peut <em>panique</em> si hors-limites. Si l’index peut
                être
                invalide, préférez une API sûre (selon la stdlib dispo) ou testez <code>i &lt; v.len()</code> avant.</p>
        </div>

        <h3>8.8 <code>std.debug</code> — Assertions &amp; debug</h3>
        <pre><code>import std::debug

debug::assert(2 + 2 == 4)
debug::dump("state=INIT")        // trace lisible rapide
// Selon l'environnement, on peut obtenir une backtrace si activée au build `-g`.
</code></pre>

        <h3>8.9 <code>std.err</code> — Erreurs structurées</h3>
        <p><em>But</em> : centraliser l’information d’erreur (catégorie, message, contexte) et mapper vers des codes de
            sortie stables.</p>
        <pre><code>import std::{err, io}

fn parse_threshold(s:str) -&gt; Result&lt;i64, err::Error&gt; {
  match std.str::to_int(s) {
    Result::Ok(v) =&gt; return Result::Ok(v),
    Result::Err(_) =&gt; return Result::Err(err::Error::new("parse int échoué")),
  }
}
</code></pre>

        <h3>8.10 <code>std.c</code> — Pont C (complément rapide)</h3>
        <p>Voir la section FFI pour le guide complet. Ici, le minimum utile.</p>
        <pre><code>import std::c

extern "C" { fn puts(msg:*const char) -&gt; i32 }
let cs = c::CString::from_str("Hello C!\n")?
unsafe { _ = puts(cs.as_ptr()) }
</code></pre>

        <h3>8.11 Patrons composés (recettes prêtes à copier)</h3>
        <h4>Lecture robuste avec message explicite</h4>
        <pre><code>import std::{fs, io}

fn show_file(path:str) -&gt; Result&lt;(), str&gt; {
  if !fs::exists(path) {
    io::eprintln("E2001: fichier introuvable → " + path)
    io::eprintln("Astuce: lancer depuis la racine du projet ou passer un chemin absolu.")
    return Result::Err("absent")
  }
  io::print(fs::read_to_string(path)?)
  return Result::Ok(())
}
</code></pre>

        <h4>Mesure de temps, factorisée</h4>
        <pre><code>import std::{time, io}

fn timed(label:str, f: fn()-&gt;()) -&gt; () {
  let t0 = time::now()
  f()
  io::println(label + ":" + (time::now()-t0).to_string() + " ms")
}
</code></pre>

        <h4>Parsing fiable d’un entier (fichier config)</h4>
        <pre><code>import std::{fs, str, err}

fn load_threshold(path:str) -&gt; Result&lt;i64, err::Error&gt; {
  let s = fs::read_to_string(path)?
  match str::to_int(str::replace(s, "\n", "")) {
    Result::Ok(v) =&gt; return Result::Ok(v),
    Result::Err(_) =&gt; return Result::Err(err::Error::new("parse int échoué")),
  }
}
</code></pre>

        <h3>8.12 FAQ débutant</h3>
        <details>
            <summary>« Pourquoi certaines fonctions retournent un <code>Result</code> ? »</summary>
            <p>Parce que l’opération peut échouer (fichier manquant, permissions, entrée invalide). Le type
                <code>Result</code> oblige à y penser et à gérer l’échec, ou à le propager avec <code>?</code>.
            </p>
        </details>
        <details>
            <summary>« Quand utiliser <code>println</code> vs <code>eprintln</code> ? »</summary>
            <p><code>println</code> pour la sortie « normale » (données destinées à l’utilisateur ou à un pipeline).
                <code>eprintln</code> pour les diagnostics et erreurs.
            </p>
        </details>
        <details>
            <summary>« Comment concaténer un nombre et une chaîne ? »</summary>
            <p>Convertissez d’abord le nombre&nbsp;: <code>"n=" + n.to_string()</code>. VITL ne devine pas le format
                pour
                éviter les ambiguïtés.</p>
        </details>

        <h3>8.13 Aide-mémoire (quick ref)</h3>
        <div class="card">
            <ul>
                <li><strong>IO</strong> : <code>print</code> · <code>println</code> · <code>eprintln</code></li>
                <li><strong>FS</strong> : <code>exists</code> · <code>read_to_string</code> · <code>read</code> ·
                    <code>write_string</code>
                </li>
                <li><strong>STR</strong> : <code>len</code> · <code>split</code> · <code>find</code> ·
                    <code>replace</code> ·
                    <code>to_int</code> · <code>to_float</code>
                </li>
                <li><strong>MATH</strong> : <code>sqrt</code> · <code>abs</code></li>
                <li><strong>TIME</strong> : <code>now</code> · soustraction → durée → <code>to_string()</code></li>
                <li><strong>CLI</strong> : <code>args</code> · <code>env</code></li>
                <li><strong>VEC</strong> : <code>with_capacity</code> · <code>push</code> · <code>pop</code> ·
                    <code>len</code>
                </li>
                <li><strong>DEBUG</strong> : <code>assert</code> · <code>dump</code></li>
                <li><strong>ERR</strong> : <code>err::Error::new</code></li>
                <li><strong>C</strong> : <code>c::CString::from_str</code> → <code>extern "C"</code> →
                    <code>unsafe</code>
                </li>
            </ul>
        </div>

        <!-- Rappel express -->
        <pre><code>import std.{io, fs, str, math, time, cli, vec, debug, err, c}

io::println("Hello")
_ = fs::write_string("out.txt", "ok\n")?
let n = str::len("abc") // 3
let t0 = time::now(); heavy(); io::println((time::now()-t0).to_string()+" ms")
</code></pre>
    </section>

    <hr />


    <!-- 9) STYLE -->
    <section id="style">
        <h2>9) Style et bonnes pratiques — ultra-guide débutant (utile aux pros)</h2>

        <div class="callout info">
            <h4>Philosophie</h4>
            <p>Le but n’est pas d’écrire « du code qui marche », mais du code que <strong>tout le monde</strong> peut
                comprendre, modifier et tester <strong>rapidement</strong>. VITL encourage la clarté&nbsp;: immutabilité
                par
                défaut, erreurs explicites, modules simples.</p>
            <ul>
                <li><strong>Lisibilité &gt; Astuce</strong> : choisissez le nom clair plutôt que l’expression trop
                    compacte.
                </li>
                <li><strong>Prévisibilité</strong> : pas d’effets de bord « surprise », pas de conversion implicite.
                </li>
                <li><strong>Moins, mais mieux</strong> : une responsabilité par fonction, un fichier = un module.</li>
            </ul>
        </div>

        <h3>9.1 Structure type d’un fichier</h3>
        <ol>
            <li><strong>module</strong> (doit refléter le chemin disque)</li>
            <li><strong>imports</strong> groupés/par ordre hiérarchique</li>
            <li><strong>constantes</strong> publiques → privées</li>
            <li><strong>types</strong> (struct/enum) puis <strong>impl</strong></li>
            <li><strong>fonctions</strong> publiques → privées</li>
            <li><strong>tests</strong> à la fin</li>
        </ol>
        <pre><code>// src/math/geom.vitl
module math.geom
import std.{math, io}

const EPS:f64 = 1e-9

struct Vec2 { x:f64, y:f64 }

impl Vec2 {
  fn norm(&amp;self)-&gt;f64 { return (self.x*self.x + self.y*self.y).sqrt() }
}

pub fn dist(a:Vec2, b:Vec2)-&gt;f64 { return Vec2{ x:a.x-b.x, y:a.y-b.y }.norm() }

test "distance nulle sur même point" { assert(dist(Vec2{x:0,y:0}, Vec2{x:0,y:0}) &lt; EPS) }
</code></pre>

        <h3>9.2 Nommage (clair et constant)</h3>
        <ul>
            <li><strong>snake_case</strong> pour variables/fonctions ; <strong>CamelCase</strong> pour types.</li>
            <li>Noms parlants : <code>timeout_ms</code>, <code>max_items</code>, <code>parse_config</code>.</li>
            <li>Préfixez les « jetables » par <code>_</code> : <code>let _unused = ...</code> pour signaler l’intention.
            </li>
        </ul>
        <pre><code>// Mieux
fn read_user_file(path:str)-&gt;Result&lt;String,str&gt; { ... }
// À éviter
fn ruf(p:str)-&gt;Result&lt;String,str&gt; { ... }
</code></pre>

        <h3>9.3 Mise en forme (formatter)</h3>
        <ul>
            <li>Utilisez <code>vitl fmt</code> régulièrement (CI conseillée).</li>
            <li>Lignes courtes (≈100 colonnes), blocs aérés, imports triés.</li>
            <li>1 déclaration par ligne, pas d’« one-liners » opaques.</li>
        </ul>

        <h3>9.4 Imports</h3>
        <ul>
            <li>Groupez par familles : <code>std.{io, fs}</code> puis vos modules internes.</li>
            <li>Importez juste ce qu’il faut (limite les collisions et clarifie les usages).</li>
        </ul>
        <pre><code>import std.{io, fs}
import util.{strfmt, path}
</code></pre>

        <h3>9.5 Fonctions : petite surface, retours clairs</h3>
        <ul>
            <li>Une fonction = une idée. Si vous avez « et puis », scindez.</li>
            <li>Types explicites aux frontières (API publiques, FFI, I/O).</li>
            <li><strong>Early return</strong> pour les erreurs/conditions simples → code en « flèche droite ».</li>
        </ul>
        <pre><code>// Mauvais : imbriqué
fn load(p:str)-&gt;Result&lt;String,str&gt;{
  if std.fs::exists(p){
    return std.fs::read_to_string(p)
  } else {
    return Result::Err("absent")
  }
}
// Mieux : early return + message clair
fn load(p:str)-&gt;Result&lt;String,str&gt;{
  if !std.fs::exists(p) { return Result::Err("E2001: absent:"+p) }
  return std.fs::read_to_string(p)
}
</code></pre>

        <h3>9.6 Erreurs : conventions</h3>
        <ul>
            <li>Utilisez <code>Result&lt;T,E&gt;</code> pour toute opération risquée.</li>
            <li>Propagez avec <code>?</code> tant que le message d’origine est suffisant.</li>
            <li>Codes de sortie stables : <strong>0</strong>=OK, <strong>1</strong>=panic, <strong>2</strong>=usage,
                <strong>3</strong>=I/O, <strong>4</strong>=FFI.
            </li>
        </ul>
        <pre><code>fn run(path:str)-&gt;i32 {
  match app::do_work(path) {
    Result::Ok(_)  =&gt; return 0,
    Result::Err(e) =&gt; { std.io::eprintln(e); return 3 }
  }
}
</code></pre>

        <h3>9.7 Données : immutabilité, <code>mut</code> avec parcimonie</h3>
        <ul>
            <li>Déclarez immuable par défaut (<code>let</code>), introduisez <code>mut</code> au plus près du besoin.
            </li>
            <li>Préférez les <em>transformations</em> claires aux mutations cachées.</li>
        </ul>
        <pre><code>let mut acc:i64 = 0
for n in 0..=100 { acc = acc + n }
</code></pre>

        <h3>9.8 Chaînes &amp; formatage</h3>
        <ul>
            <li>Convertissez explicitement : <code>"n=" + n.to_string()</code>.</li>
            <li>Centralisez les formats communs (ex. <code>util::strfmt</code>).</li>
        </ul>

        <h3>9.9 Boucles, conditions, <code>match</code></h3>
        <ul>
            <li>Préférez <code>match</code> exhaustif pour les enums (vous ne « oublierez » pas de cas).</li>
            <li>Limitez les <code>break/continue</code> multiples : c’est plus lisible.</li>
        </ul>
        <pre><code>match status {
  Status::Ok      =&gt; {},
  Status::Err(e)  =&gt; std.io::eprintln(e),
}
</code></pre>

        <h3>9.10 Tests (AAA : Arrange, Act, Assert)</h3>
        <ul>
            <li>Un test = un comportement. Nommez-le comme une phrase.</li>
            <li>Placez les tests en bas du fichier du module testé.</li>
        </ul>
        <pre><code>test "parse: nombre valide" {
  // Arrange
  let s = "42"
  // Act
  let n = std.str::to_int(s).unwrap()
  // Assert
  assert(n == 42)
}
</code></pre>

        <h3>9.11 Commentaires &amp; documentation</h3>
        <ul>
            <li>Commentez le « pourquoi », pas le « quoi » (le code dit déjà le quoi).</li>
            <li>Utilisez <code>///</code> pour la doc générée par <code>vitl doc</code>.</li>
        </ul>
        <pre><code>/// Convertit une chaîne en entier signé.
/// Retourne Err si la chaîne n'est pas un entier valide.
fn parse_i64(s:str)-&gt;Result&lt;i64,str&gt; { return std.str::to_int(s) }
</code></pre>

        <h3>9.12 Logs &amp; debug</h3>
        <ul>
            <li>Logguez sur <code>eprintln</code> les diagnostics (niveau simple).</li>
            <li>Évitez le bruit : messages courts avec un identifiant stable (ex. <code>E2001</code>).</li>
        </ul>

        <h3>9.13 Performance (sans prématurité)</h3>
        <ul>
            <li>Mesurez avant d’optimiser : <code>std.time::now()</code> autour du bloc.</li>
            <li>Évitez les copies inutiles (itération par <code>&amp;v</code>).</li>
            <li>Allouez à l’avance si la taille est connue : <code>vec::with_capacity</code>.</li>
        </ul>

        <h3>9.14 FFI &amp; sécurité (rappel de style)</h3>
        <ul>
            <li>Encapsulez l’<code>unsafe</code> dans une API sûre et documentée.</li>
            <li>Documentez l’ownership des buffers passés au C (qui libère&nbsp;?).</li>
        </ul>

        <h3>9.15 Exemples « avant / après »</h3>
        <div class="grid-2">
            <div>
                <p><strong>Avant (compact mais obscur)</strong></p>
                <pre><code>fn r(p:str)-&gt;i32{if!std.fs::exists(p){std.io::eprintln("x");return 3}
std.io::print(std.fs::read_to_string(p).unwrap());return 0}
</code></pre>
            </div>
            <div>
                <p><strong>Après (clair et robuste)</strong></p>
                <pre><code>/// Affiche le contenu d'un fichier texte.
/// Codes : 0 ok, 3 I/O manquant.
fn run(path:str)-&gt;i32 {
  if !std.fs::exists(path) {
    std.io::eprintln("E2001: fichier introuvable → " + path)
    return 3
  }
  match std.fs::read_to_string(path) {
    Result::Ok(s)  =&gt; { std.io::print(s); return 0 },
    Result::Err(e) =&gt; { std.io::eprintln(e); return 3 },
  }
}
</code></pre>
            </div>
        </div>

        <h3>9.16 Checklist « revue rapide »</h3>
        <ul>
            <li>[ ] Nom du module = chemin du fichier</li>
            <li>[ ] Imports triés et minimaux</li>
            <li>[ ] Fonctions courtes (≤ ~20–30 lignes) ou clairement découpées</li>
            <li>[ ] Types explicites aux frontières d’API</li>
            <li>[ ] Erreurs via <code>Result</code> + messages utiles (codes stables si pertinent)</li>
            <li>[ ] Immutabilité par défaut ; <code>mut</code> localisé</li>
            <li>[ ] Tests nommés, AAA respecté</li>
            <li>[ ] <code>vitl fmt</code> exécuté</li>
        </ul>

        <div class="card">
            <strong>Raccourcis utiles (mémo)</strong>
            <ul>
                <li>Un fichier = un module (nom = chemin)</li>
                <li>Imports groupés et triés par hiérarchie</li>
                <li>Tests en bas du fichier (exemples minimaux et cas d’erreur)</li>
                <li>Messages d’erreur courts avec un identifiant (ex. <code>E2001</code>)</li>
                <li>Mesurer avant d’optimiser</li>
            </ul>
        </div>

        <pre><code>let user_name = "Alice"
fn compute_area(w:i32, h:i32) -&gt; i32 { return w*h }
struct Rectangle { width:i32, height:i32 }
</code></pre>
    </section>

    <hr />


    <!-- 10) NIVEAUX -->
    <section id="niveaux">
        <h2>10) Conseils par niveau — guide progressif pour tous publics</h2>

        <div class="callout info">
            <h4>Comment utiliser cette section</h4>
            <p>Choisissez votre point de départ, puis avancez palier par palier. Chaque niveau propose :
                <strong>objectifs clairs</strong>, <strong>mini-projets</strong> avec critères de réussite, et
                <strong>erreurs
                    fréquentes</strong>.
                Vous pouvez parcourir rapidement les paragraphes grisés (notes) et revenir aux encadrés pratiques pour
                consolider.
            </p>
        </div>

        <!-- Débutant -->
        <div class="card" style="margin-bottom:16px">
            <strong>Débutant — poser des bases solides</strong>
            <p>À ce stade, l’objectif est d’écrire de <em>petits programmes qui s’exécutent sans surprise</em>.
                Vous apprendrez à lire/écrire sur la console, manipuler quelques variables, appeler des fonctions de la
                bibliothèque standard et comprendre les messages d’erreur. Concentrez-vous sur la structure d’un fichier
                (module → imports → fonctions) et sur l’immutabilité par défaut.</p>

            <h4>Objectifs d’apprentissage</h4>
            <ul>
                <li>Savoir créer un fichier <code>src/main.vitl</code>, le lancer avec <code>vitl run</code>, puis le
                    compiler.</li>
                <li>Afficher du texte, lire un fichier existant en gérant l’échec (fichier manquant).</li>
                <li>Comprendre la différence <code>str</code> vs <code>String</code> et quand utiliser <code>mut</code>.
                </li>
                <li>Écrire un <strong>premier test</strong> qui vérifie un calcul simple.</li>
            </ul>

            <h4>Mini-projets (avec critères de réussite)</h4>
            <ol>
                <li><em>Hello</em> : afficher « Bonjour Vitte Light ». <span class="note">Réussite : programme renvoie
                        0.</span></li>
                <li><em>Écho de fichier</em> : lire un chemin argument et afficher le contenu.
                    <span class="note">Réussite : message clair si le fichier n’existe pas (code 3).</span>
                </li>
                <li><em>Compteur</em> : afficher 0..N (inclus) depuis un argument.
                    <span class="note">Réussite : N négatif → message d’usage (code 2).</span>
                </li>
            </ol>

            <pre><code>// Débutant : compteur 0..=N
module app.counter
import std.{io, cli, str}

fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) != 2 { io::eprintln("usage: counter &lt;n&gt;"); return 2 }
  let n = str::to_int(a[1])?
  if n &lt; 0 { io::eprintln("n doit être ≥ 0"); return 2 }
  for i in 0..=(n as i32) { io::println(i.to_string()) }
  return 0
}
</code></pre>

            <h4>Erreurs fréquentes &amp; remèdes</h4>
            <ul>
                <li><strong>E0001 symbole inconnu</strong> → vérifier l’<code>import</code> et l’orthographe des
                    fonctions.
                </li>
                <li><strong>E0002 types incompatibles</strong> → convertir explicitement (<code>to_string()</code>,
                    <code>as</code>).
                </li>
                <li>Oublier <code>mut</code> pour modifier une variable → ajouter <code>let mut</code>.</li>
            </ul>

            <h4>Routine « 20 minutes »</h4>
            <p>1) Écrire 10 lignes qui s’exécutent. 2) Lancer <code>vitl fmt</code>. 3) Casser volontairement un cas
                (fichier manquant)
                et lire le message d’erreur. 4) Ajouter un test minimal.</p>
        </div>

        <!-- Intermédiaire -->
        <div class="card" style="margin-bottom:16px">
            <strong>Intermédiaire — construire des outils fiables</strong>
            <p>Ici, vous structurez vos programmes en modules, vous gérez les erreurs avec <code>Result</code> et
                l’opérateur <code>?</code>,
                et vous commencez à <em>mesurer</em> vos programmes (temps d’exécution, taille des E/S). L’objectif est
                de
                livrer des
                <strong>CLI robustes</strong> avec des messages d’erreur utiles, des codes de sortie stables et quelques
                tests.
            </p>

            <h4>Objectifs d’apprentissage</h4>
            <ul>
                <li>Découper en modules (un fichier = un module) et utiliser des imports groupés.</li>
                <li>Étoffer les messages d’erreur (contexte + code) et propager proprement avec <code>?</code>.</li>
                <li>Introduire des <strong>tests</strong> (cas heureux + cas d’erreur) dans chaque module.</li>
                <li>Mesurer le temps d’une opération avec <code>std.time::now()</code>.</li>
            </ul>

            <h4>Mini-projets</h4>
            <ol>
                <li><em>cat++</em> : concaténer plusieurs fichiers passés en arguments, ignorer ceux manquants avec un
                    avertissement.</li>
                <li><em>todo CLI</em> : gérer une liste (ajout, liste, suppression) dans un fichier texte dans
                    <code>$HOME</code>.
                </li>
                <li><em>statlog</em> : lire un fichier, compter les lignes/mots/caractères, afficher le temps
                    d’exécution.
                </li>
            </ol>

            <pre><code>// Intermédiaire : "cat++" avec erreurs contextualisées
module app.catpp
import std.{io, fs, cli, str, time}

fn main()-&gt;i32 {
  let a = cli::args()
  if str::len(a) &lt; 2 { io::eprintln("usage: catpp &lt;fichiers...&gt;"); return 2 }
  let t0 = time::now()
  let mut shown:i32 = 0
  for i in 1..str::len(a) {
    let p = a[i]
    if !fs::exists(p) { io::eprintln("E2001: introuvable → " + p); continue }
    match fs::read_to_string(p) {
      Result::Ok(s)  =&gt; { io::print(s); shown = shown + 1 },
      Result::Err(e) =&gt; io::eprintln("E2002: lecture échouée → " + p + " (" + e + ")"),
    }
  }
  io::eprintln("ms=" + (time::now()-t0).to_string())
  return if shown &gt; 0 { 0 } else { 3 }
}
</code></pre>

            <h4>Profil d’erreurs (et parades)</h4>
            <ul>
                <li>« <em>C’est passé en local mais pas en CI</em> » → figer le chemin de travail, tester avec chemins
                    relatifs contrôlés.</li>
                <li>« <em>Crash silencieux</em> » → écrire sur <code>eprintln</code> les infos minimales (code + cause).
                </li>
                <li>« <em>Perfs en berne</em> » → éviter les copies, itérer par référence <code>&amp;v</code>, lire en
                    blocs.
                </li>
            </ul>

            <h4>Indicateurs de progression</h4>
            <p>Vous savez écrire un binaire <code>-O2</code> avec des erreurs contextualisées, vous avez au moins deux
                tests
                par module,
                et vous pouvez expliquer en 2 phrases la responsabilité de chaque fichier.</p>
        </div>

        <!-- Professionnel -->
        <div class="card" style="margin-bottom:16px">
            <strong>Professionnel — livrer, intégrer, maintenir</strong>
            <p>Le but est de produire des <strong>binaires fiables</strong>, intégrés à une chaîne CI/CD, avec une
                surface
                FFI C
                <em>minimale et sûre</em> si nécessaire. Vous définissez des conventions d’équipe (codes d’erreurs,
                structure
                des modules,
                checklist de revue), vous générez la documentation à partir des commentaires <code>///</code> et vous
                surveillez la qualité via
                des tests automatiques.
            </p>

            <h4>Objectifs d’apprentissage</h4>
            <ul>
                <li>Stabiliser un <strong>contrat d’API</strong> (types aux frontières, erreurs catégorisées).</li>
                <li>Encapsuler l’<code>unsafe</code> FFI dans des fonctions VITL sûres et testées.</li>
                <li>Automatiser <code>fmt</code>/<code>check</code>/<code>test</code>/<code>doc</code> en CI, publier
                    des
                    artefacts.</li>
                <li>Instrumenter : mesurer (temps, tailles), journaliser sobrement, documenter les hypothèses.</li>
            </ul>

            <h4>Mini-projets</h4>
            <ol>
                <li><em>Wrapper C</em> : appeler une fonction C (ex. <code>puts</code>) via <code>CString</code>, tests
                    d’intégration.</li>
                <li><em>Plugin .vitbc</em> : charger un bytecode et exposer une API de scripts contrôlée.</li>
                <li><em>Doc &amp; release</em> : générer <code>vitl doc</code>, produire un binaire <code>-O3</code>,
                    SHA256
                    et changelog.</li>
            </ol>

            <pre><code>// Pro : FFI encap + mapping d'erreurs
module app.ffi_safe
import std.{io, c}

extern "C" { fn puts(msg:*const char)-&gt;i32 }

fn c_puts_line(s:str)-&gt;Result&lt;(),str&gt; {
  let cs = c::CString::from_str(s)?
  let rc = unsafe { puts(cs.as_ptr()) }
  if rc &lt; 0 { return Result::Err("E0701: puts a échoué") }
  return Result::Ok(())
}

fn main()-&gt;i32 {
  match c_puts_line("Hello C!\n") {
    Result::Ok(_)  =&gt; return 0,
    Result::Err(e) =&gt; { io::eprintln(e); return 4 }
  }
}
</code></pre>

            <h4>Checklist « prêt à livrer »</h4>
            <ul>
                <li>Types explicites aux frontières, <code>unsafe</code> encapsulé, ownership documenté.</li>
                <li>Tests : réussite/échec couverts, temps d’exécution borné.</li>
                <li>Doc générée depuis <code>///</code>, lue et à jour.</li>
                <li>Codes de sortie stables (0/1/2/3/4) et messages concis.</li>
            </ul>

            <h4>Signaux de maturité</h4>
            <p>Vous pouvez brancher une lib C sans fuite, diagnostiquer un crash avec un backtrace,
                et expliquer en 30 secondes comment reproduire un bug (commande + entrée minimale).</p>
        </div>

        <!-- Coach/Lead & filières -->
        <div class="grid-2" style="gap:16px">
            <div class="card">
                <strong>Coach / Lead — cadrer et accélérer</strong>
                <p>Installez des garde-fous simples : gabarit de fichier (module/imports/tests), rubriques de code
                    review
                    (noms, erreurs, tests), matrice des codes d’erreurs, et script de vérification locale
                    (<code>fmt</code> + <code>check</code> + <code>test</code>).</p>
                <ul>
                    <li>Revue = vérifier <em>le pourquoi</em> (doc), <em>le quoi</em> (API claire) et <em>le
                            comment</em> (impl
                        lisible).</li>
                    <li>Favoriser les <em>petites PRs</em> avec mini-projets livrables en &lt; 1 jour.</li>
                </ul>
            </div>
            <div class="card">
                <strong>Filières (adapter l’apprentissage)</strong>
                <p><em>Scripting/ops</em> : std.io/std.fs/std.cli, messages d’erreur concrets, packaging binaire.</p>
                <p><em>Données/ETL</em> : lecture par blocs, parsers ligne à ligne, mesure de temps E/S.</p>
                <p><em>Systèmes/embarqué</em> : tailles fixes, conversions explicites, FFI stricte et documentée.</p>
            </div>
        </div>

        <div class="card" style="margin-top:16px">
            <strong>Parcours 30-60-90 jours (indicatif)</strong>
            <ol>
                <li><em>0–30</em> : 5 mini-CLI + tests basiques, erreurs contextualisées, <code>fmt</code> systématique.
                </li>
                <li><em>31–60</em> : modulariser, mesurer, documenter, ajouter CI locale (script), 1 petit wrapper C.
                </li>
                <li><em>61–90</em> : release binaire <code>-O3</code>, doc auto, matrice d’erreurs stable,
                    plugin/bytecode.
                </li>
            </ol>
        </div>

        <div class="note">Astuce : gardez un fichier « carnet de bord » avec la commande exacte pour reproduire chaque
            bug
            (entrée minimale + sortie attendue). Vous gagnerez des heures.</div>
    </section>

    <hr />


    <!-- 11) LIMITES -->
    <section id="limites">
        <h2>11) Limites (version Light) — version détaillée, tout public</h2>

        <div class="callout warn">
            <h4>Pourquoi ces limites&nbsp;?</h4>
            <p>Vitte Light est pensé pour couvrir rapidement la majorité des petits outils, scripts et utilitaires sans
                vous
                noyer dans la complexité. Pour y parvenir, le langage fait des choix qui privilégient la lisibilité, la
                prévisibilité et des binaires compacts. En contrepartie, certaines fonctionnalités « lourdes » ne sont
                pas
                intégrées nativement. Ce n’est pas une faiblesse mais un <em>périmètre assumé</em> : quand vos besoins
                dépassent ce périmètre, vous pouvez brancher une bibliothèque externe (FFI C) ou utiliser un outil
                spécialisé.
                Cette section vous explique clairement ce qui est <em>non inclus</em>, ce que cela implique
                concrètement, et
                comment contourner proprement les cas limites.</p>
        </div>

        <h3>11.1 Pas de threads natifs</h3>
        <p>Vitte Light n’inclut pas de modèle de threads intégré. Cela signifie qu’un même processus VITL n’exécutera
            pas
            deux fonctions « en parallèle » sur plusieurs cœurs. En pratique, la plupart des petits outils n’en ont pas
            besoin : lecture/écriture de fichiers, transformation de texte, génération de rapports ou appels systèmes
            séquentiels restent instantanés à l’échelle humaine. L’absence de threads évite aussi une grande classe de
            bugs
            (verrous oubliés, interblocages, conditions de course) et simplifie énormément le débogage.</p>
        <p>Si vous devez paralléliser des traitements lourds (par exemple, compresser un grand nombre de fichiers,
            calculer des hachages, convertir des images), la stratégie recommandée consiste à <strong>lancer plusieurs
                processus</strong> du même binaire et à <strong>distribuer le travail</strong> entre eux. C’est simple à
            raisonner : chaque processus a sa propre mémoire, ne partage rien, et l’OS se charge d’exploiter tous les
            cœurs.
            Vous pouvez coordonner ces processus via des fichiers temporaires, des pipes, des numéros de tâches, ou un
            petit
            superviseur en VITL qui répartit des chemins d’entrée sur N sous-processus. Pour les cas encore plus
            spécifiques
            (réseau, GPU, planification fine), appuyez-vous sur une bibliothèque native via FFI C qui expose la
            parallélisation en interne, tout en gardant une interface VITL minimaliste et sûre.</p>

        <h3>11.2 Pas de GC complet (usage de <code>Rc</code>/<code>Weak</code>)</h3>
        <p>Vitte Light ne s’appuie pas sur un ramasse-miettes global. La mémoire est gérée par <em>références
                comptées</em> (<code>Rc&lt;T&gt;</code>) : lorsqu’il n’existe plus de référence « forte » vers une
            donnée,
            elle est libérée immédiatement. C’est facile à comprendre, déboguer et anticiper. La seule vigilance
            concerne
            les <strong>cycles forts</strong> (A pointe vers B et B vers A en « fort ») qui ne peuvent pas se libérer
            tout
            seuls. La parade est simple : pour les liens de « retour » (parent → enfant → parent), utilisez une
            <code>Weak</code> sur un des côtés. Vous évitez ainsi la fuite de mémoire sans devoir installer un GC.
        </p>
        <p>Concrètement, structurez vos données avec un <em>propriétaire clair</em> (l’élément qui vit plus longtemps)
            et
            des observateurs qui n’empêchent pas la libération. Par exemple, un « Document » peut posséder en
            <code>Rc</code> ses « Sections », tandis que chaque « Section » ne conserve qu’un <code>Weak</code> vers son
            «
            Document ». Au moment de la suppression, tout se libère de manière déterministe. Si vous manipulez des
            graphes
            complexes, faites un petit audit visuel : repérez les boucles A ↔ B et convertissez le lien de retour en
            <code>Weak</code>. Pour des structures gigantesques et dynamiques où un GC serait utile, déléguez la
            structure
            au C (ou à une lib avec GC intégré) derrière un wrapper VITL finement documenté sur l’ownership.
        </p>

        <h3>11.3 Génériques partiels</h3>
        <p>Le système de types couvre les cas fréquents (fonctions et structures paramétrées simples), mais n’offre pas
            tous les raffinements des langages dédiés à la méta-programmation lourde. En clair : on privilégie des
            signatures explicites et des conversions claires aux « types magiques ». Pour un outil de 50-300 lignes,
            c’est
            un avantage : vous lisez l’API en un coup d’œil et vous évitez les erreurs implicites.</p>
        <p>Quand vous sentez que vous forcez le langage (cascade de paramètres de type, abstractions très profondes),
            c’est souvent un signal pour <strong>revenir à des types concrets</strong> et des fonctions dédiées aux 2-3
            cas
            qui comptent, ou pour <strong>mettre la généricité « exotique » derrière une API C</strong> minuscule. Vous
            gardez une interface VITL stable et vous laissez la sophistication au moteur natif.</p>

        <h3>11.4 FFI limité à l’ABI C</h3>
        <p>L’interopérabilité de Vitte Light vise l’ABI C. Cela garantit un pont fiable et portable avec un très vaste
            écosystème (libc, zlib, SQLite, etc.). En revanche, pour des bibliothèques C++/Rust/Go, vous devrez fournir
            un
            <strong>shim C</strong> : une petite couche qui expose des fonctions C pures (paramètres scalaires,
            pointeurs,
            longueurs), et qui s’occupe en interne d’appeler le code C++/Rust/Go. C’est une pratique standard : elle
            clarifie les responsabilités, stabilise la surface d’échange et simplifie le débogage.
        </p>
        <p>Le contrat à respecter est simple : les chaînes passées au C doivent être des <code>CString</code> valides
            (UTF-8 sans <code>\0</code> interne) et leur durée de vie doit couvrir l’appel. Documentez clairement qui
            alloue
            et qui libère chaque tampon. Si la lib vous renvoie un pointeur alloué de son côté, prévoyez la fonction de
            libération correspondante et appelez-la systématiquement. En cas d’erreur, mappez les codes natifs vers des
            messages clairs côté VITL et convertissez en codes de sortie stables (par exemple, « 4 » pour une erreur
            FFI).
        </p>

        <h3>11.5 Performances et mémoire : à quoi s’attendre</h3>
        <p>Pour des scripts et utilitaires, Vitte Light offre des <strong>temps de démarrage très courts</strong> et des
            binaires légers, avec des performances « assez bonnes » en I/O et en calcul numérique classique. L’absence
            de
            threads intégrés ne pénalise pas les tâches séquentielles, et l’absence de GC évite des pauses non
            déterministes. Les optimisations usuelles suffisent le plus souvent : lire/écrire en blocs plutôt que
            caractère
            par caractère, éviter les copies inutiles, réutiliser des tampons, convertir explicitement pour éviter les
            promotions coûteuses, et compiler en <code>-O2</code> (ou <code>-O3</code> si le binaire final le justifie).
            Si
            un hot-spot reste déterminant, déportez-le dans une fonction C spécialisée et appelez-la via FFI.</p>

        <h3>11.6 I/O intensives et très gros fichiers</h3>
        <p>Pour des fichiers énormes (journaux massifs, dumps), privilégiez le <strong>traitement en flux</strong> :
            lire
            par blocs (ou ligne par ligne) et traiter au fil de l’eau. Évitez de charger tout un fichier en mémoire,
            sauf si
            c’est réellement nécessaire. Cette approche garde la consommation mémoire stable et rend votre utilitaire
            robuste face à des entrées plus volumineuses que prévu. En complément, mesurez le temps
            (<code>std.time::now()</code>) et affichez une synthèse sobre en sortie d’erreur (durée, octets lus, lignes
            traitées) pour diagnostiquer facilement les goulots d’étranglement.</p>

        <h3>11.7 Portabilité et environnement</h3>
        <p>Vitte Light vise Linux, BSD, macOS et Windows. Quelques différences existent selon l’OS (droits d’exécution,
            chemins, encodages de console). Restez sur des chemins relatifs maîtrisés, vérifiez <code>exists</code>
            avant
            lecture, et affichez des messages d’erreur <em>concrets</em> (chemin, cause). En FFI, tenez compte des
            conventions d’édition de liens (<code>-L</code>/<code>-l</code>, <em>rpath</em>) et fournissez des
            instructions
            claires pour retrouver la bibliothèque au lancement (variable d’environnement, dossier <code>libs/</code> du
            projet).</p>

        <h3>11.8 Quand « sortir » du périmètre Vitte Light</h3>
        <p>Posez-vous trois questions simples. <strong>1)</strong> Le besoin est-il ponctuel et localisé ? Si oui, vous
            pouvez souvent rester en VITL et, si nécessaire, appeler une ou deux fonctions C ciblées.
            <strong>2)</strong> Le
            besoin est-il central et persistant (calcul distribué, UI lourde, moteur 3D, GC sophistiqué) ? Dans ce cas,
            mieux vaut déléguer ce cœur à une lib native éprouvée et ne garder en VITL que la « colle » et le flux.
            <strong>3)</strong> Le besoin touche-t-il l’infrastructure (threads complexes, scheduling, GPU) au point
            d’absorber tout le projet ? Alors utilisez un langage/outil dédié pour ce sous-système et exposez une
            interface
            C propre pour que VITL puisse l’orchestrer.
        </p>

        <h3>11.9 En résumé</h3>
        <p>Vitte Light est un <strong>langage d’efficacité pragmatique</strong> : rapide à apprendre, rapide à livrer,
            fluide à maintenir. Les limites énumérées ici ne sont pas des blocages, mais des garde-fous qui vous aident
            à
            décider quand rester simple, quand composer avec des processus, et quand brancher une bibliothèque native.
            En
            gardant l’interface VITL claire et en documentant vos hypothèses (ownership, erreurs, chemins), vous
            obtiendrez
            des outils <em>robustes, portables et faciles à diagnostiquer</em>—exactement ce dont on a besoin au
            quotidien.
        </p>
    </section>

    <hr />


    <!-- 12) CODES -->
    <section id="codes-sortie">
        <h2>12) Codes de sortie — guide ultra complet, tout public</h2>

        <div class="callout info">
            <h4>À quoi servent les codes de sortie&nbsp;?</h4>
            <p>Chaque programme Vitte Light (VITL) se termine avec un <strong>entier</strong> appelé «&nbsp;code de
                sortie&nbsp;». Par convention&nbsp;:
                <strong>0</strong> signifie «&nbsp;succès&nbsp;», et toute valeur <strong>non nulle</strong> signale une
                erreur.
                Les scripts, CI/CD, et autres outils automatiques s’appuient sur ce code pour décider quoi faire ensuite
                (continuer, réessayer, alerter, etc.). Dans VITL, le code de sortie est simplement la valeur renvoyée
                par
                <code>fn main() -&gt; i32</code>.
            </p>
        </div>

        <h3>12.1 Principes de base</h3>
        <ul>
            <li><strong>Succès</strong>&nbsp;: retournez <code>0</code> depuis <code>main</code>.</li>
            <li><strong>Échec</strong>&nbsp;: retournez un entier non nul (idéalement documenté) et écrivez un message
                lisible sur <code>stderr</code> via <code>std.io::eprintln</code>.</li>
            <li><strong>Panic</strong>&nbsp;: un <code>panic("...")</code> interrompt le programme et se traduit par un
                échec (convention&nbsp;: <code>1</code>), avec un message/trace en mode debug (<code>-g</code>).</li>
            <li><strong>Lisibilité</strong>&nbsp;: combinez un <em>code stable</em> + un <em>message clair</em> pour
                aider
                humains et machines.</li>
        </ul>

        <h3>12.2 Table des codes (noyau + recommandations)</h3>
        <p>VITL standardise un petit noyau (0–4). Vous pouvez étendre avec des identifiants supplémentaires si votre
            outil
            le nécessite.</p>

        <div class="card" style="overflow:auto">
            <table>
                <thead>
                    <tr>
                        <th>Code</th>
                        <th>Nom court</th>
                        <th>Quand l’utiliser</th>
                        <th>Message typique (stderr)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>0</strong></td>
                        <td>EX_OK</td>
                        <td>Exécution normale</td>
                        <td>(pas de message d’erreur)</td>
                    </tr>
                    <tr>
                        <td><strong>1</strong></td>
                        <td>EX_GENERIC</td>
                        <td>Erreur générique / <code>panic</code></td>
                        <td><code>erreur: échec interne; réessayez avec -g</code></td>
                    </tr>
                    <tr>
                        <td><strong>2</strong></td>
                        <td>EX_USAGE</td>
                        <td>Mauvais arguments CLI, aide requise</td>
                        <td><code>usage: app &lt;fichier&gt; [options]</code></td>
                    </tr>
                    <tr>
                        <td><strong>3</strong></td>
                        <td>EX_IO</td>
                        <td>Fichiers/chemins/droits I/O</td>
                        <td><code>E2001: fichier introuvable → data.txt</code></td>
                    </tr>
                    <tr>
                        <td><strong>4</strong></td>
                        <td>EX_FFI</td>
                        <td>Appel bibliothèque native (C) a échoué</td>
                        <td><code>E0701: FFI call failed (rc=-1)</code></td>
                    </tr>
                    <!-- Recommandations optionnelles -->
                    <tr>
                        <td>5</td>
                        <td>EX_CONFIG</td>
                        <td>Config manquante/invalide</td>
                        <td><code>E3001: config.toml invalide (clé 'port')</code></td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>EX_NET</td>
                        <td>Réseau (DNS, socket, TLS)</td>
                        <td><code>E4002: connexion refusée host:port</code></td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>EX_DATA</td>
                        <td>Données d’entrée invalides</td>
                        <td><code>E5001: JSON invalide à la ligne 12</code></td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>EX_TIMEOUT</td>
                        <td>Opération expirée</td>
                        <td><code>E6001: délai dépassé (5s)</code></td>
                    </tr>
                    <tr>
                        <td>9</td>
                        <td>EX_PERM</td>
                        <td>Permission refusée</td>
                        <td><code>E6002: accès refusé → /root/out</code></td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>EX_UNSUP</td>
                        <td>Fonction non supportée ici</td>
                        <td><code>E6003: option --gpu non supportée</code></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <p class="note">Bonnes pratiques&nbsp;: restez dans une petite plage (0–15) et documentez-la. Les environnements
            POSIX normalisent l’état sur 8 bits (0–255). Des valeurs négatives peuvent être interprétées de façon
            imprévisible — évitez-les.</p>

        <h3>12.3 Exemple canonique&nbsp;: mapper les erreurs vers un code</h3>
        <pre><code>// Style recommandé : une fonction "run" retourne Result, "main" traduit en code.
module app.main
import std.{io, fs, str}

const EX_OK:i32      = 0
const EX_GENERIC:i32 = 1
const EX_USAGE:i32   = 2
const EX_IO:i32      = 3

fn run() -&gt; Result&lt;(), str&gt; {
  let argv = std.cli::args()
  if str::len(argv) &lt; 2 {
    return Result::Err("usage: app &lt;fichier&gt;")
  }
  let path = argv[1]
  if !std.fs::exists(path) {
    return Result::Err("E2001: fichier introuvable → " + path)
  }
  std.io::print(std.fs::read_to_string(path)?) // `?` propage l'erreur I/O
  return Result::Ok(())
}

fn main() -&gt; i32 {
  match run() {
    Result::Ok(()) =&gt; { return EX_OK }
    Result::Err(msg) =&gt; {
      std.io::eprintln(msg)
      // Heuristique simple : décider du code en fonction du message
      if std.str::starts_with(msg, "usage:") { return EX_USAGE }
      if std.str::starts_with(msg, "E2001:") { return EX_IO }
      return EX_GENERIC
    }
  }
}
</code></pre>

        <h3>12.4 Messages d’erreur&nbsp;: forme et ton</h3>
        <ul>
            <li><strong>Clairs, concis</strong> (une à deux lignes). Indiquez <em>quoi</em> + <em>où</em> +
                <em>piste</em>.
            </li>
            <li><strong>stderr</strong> pour les erreurs (<code>eprintln</code>), <strong>stdout</strong> pour les
                résultats.</li>
            <li><strong>Stable</strong> : conservez les mêmes codes et formats dans le temps ; évitez de «&nbsp;changer
                de
                sens&nbsp;».</li>
        </ul>
        <pre><code>// I/O robuste (extrait)
let path = argv[1]
if !std.fs::exists(path) {
  std.io::eprintln("E2001: fichier introuvable → " + path)
  std.io::eprintln("Astuce: lancez depuis la racine du projet ou passez un chemin absolu.")
  return EX_IO
}
</code></pre>

        <h3>12.5 Conventions CLI usuelles</h3>
        <ul>
            <li><strong>Usage invalide</strong> → code <code>2</code>, afficher l’aide courte. Évitez une stacktrace.
            </li>
            <li><strong>Échec interne</strong> (bug, invariant cassé) → code <code>1</code>, suggérer <code>-g</code>
                pour
                plus de traces.</li>
            <li><strong>Lecture/écriture</strong> → code <code>3</code>, préciser le chemin et la cause probable.</li>
            <li><strong>FFI</strong> → code <code>4</code>, inclure le <em>return code</em> natif si disponible.</li>
        </ul>

        <h3>12.6 Intégration shell, CI/CD et pipelines</h3>
        <div class="card">
            <ul>
                <li><strong>Bash</strong>&nbsp;: récupérer le code avec <code>$?</code> (immédiat après la commande).
                    Dans un
                    pipeline, seul le dernier code est renvoyé&nbsp;; utilisez <code>set -o pipefail</code> pour que le
                    pipeline
                    échoue si n’importe quel maillon échoue.</li>
                <li><strong>PowerShell</strong>&nbsp;: code dans <code>$LASTEXITCODE</code>.</li>
                <li><strong>Make/CI</strong>&nbsp;: toute valeur non nulle fait échouer la cible/job. Mappez vos échecs
                    «&nbsp;attendus&nbsp;» (usage, données invalides) vers des codes distincts si vos jobs doivent
                    réagir
                    différemment.</li>
            </ul>
        </div>
        <pre><code># bash
vitl build -O2 -o build/app src/main.vitl &amp;&amp; ./build/app data.txt
echo "exit=$?"

# pipelines
set -o pipefail
./produce | ./filter | ./consume
echo "pipeline exit=$?"
</code></pre>

        <h3>12.7 JSON + codes (outil scriptable)</h3>
        <p>Pour un outil consommé par d’autres programmes, couplez un <strong>code</strong> avec une <strong>sortie
                JSON</strong> courte afin
            de mêler lisibilité humaine et robustesse machine.</p>
        <pre><code>// Exemple : en cas d'erreur, JSON minimal sur stdout, détails sur stderr.
fn main() -&gt;i32 {
  match run() {
    Result::Ok(()) =&gt; { std.io::println(r#"{"ok":true}"#); return 0 }
    Result::Err(msg) =&gt; {
      std.io::eprintln(msg)
      std.io::println(r#"{"ok":false,"code":2}"#)
      return 2
    }
  }
}
</code></pre>

        <h3>12.8 Tests des codes de sortie</h3>
        <p>Vérifiez vos codes avec des tests système (scripts) et des tests VITL ciblés.</p>
        <pre><code># test shell (ex.)
./app                       # manque d'arguments
test $? -eq 2 || echo "attendu EX_USAGE"

./app data/missing.txt
test $? -eq 3 || echo "attendu EX_IO"
</code></pre>

        <h3>12.9 Questions fréquentes</h3>
        <ul>
            <li><strong>Dois-je inventer 100 codes&nbsp;?</strong> Non. 3–8 codes bien choisis suffisent pour 99&nbsp;%
                des
                utilitaires.</li>
            <li><strong>Puis-je changer un code plus tard&nbsp;?</strong> Évitez. Si nécessaire, conservez l’ancien
                comme
                alias (temporaire) et annoncez la déprecation.</li>
            <li><strong>Et Windows&nbsp;?</strong> Restez sur de petits entiers positifs. Les shells/CI modernes les
                propagent correctement.</li>
        </ul>

        <h3>12.10 Résumé opérationnel</h3>
        <div class="card">
            <ul>
                <li><strong>0</strong> succès · <strong>1</strong> générique · <strong>2</strong> usage ·
                    <strong>3</strong>
                    I/O · <strong>4</strong> FFI.
                </li>
                <li>Affichez un message clair sur <code>stderr</code> et retournez un code <em>stable</em>.</li>
                <li>Testez vos codes dans des scripts (avec <code>set -o pipefail</code> si pipeline).</li>
                <li>Pour des intégrations machine, ajoutez une sortie JSON minimale.</li>
            </ul>
        </div>
    </section>

    <hr />


    <!-- 13) DIAGNOSTICS -->
    <section id="diagnostics">
        <h2>13) Diagnostics courants — guide ultra complet, tout public</h2>

        <div class="callout info">
            <h4>Objectif</h4>
            <p>Vous aider à <strong>trouver</strong>, <strong>comprendre</strong> et <strong>corriger</strong>
                rapidement
                les erreurs de compilation et d’exécution en Vitte Light (VITL). Cette section propose une méthode de
                triage,
                des exemples concrets, des gabarits de messages, et des checklists par thème (CLI, fichiers, FFI, etc.).
            </p>
        </div>

        <h3>13.1 Méthode de triage (rapide et efficace)</h3>
        <ol>
            <li><strong>Lire le message complet</strong> (ligne, colonne, module) avant d’essayer quelque chose.</li>
            <li><strong>Isoler un MRE</strong> (Mini Repro d’Erreur)&nbsp;: réduisez le code au plus petit exemple qui
                reproduit le problème (souvent 1–2 fichiers).</li>
            <li><strong>Compiler en mode debug</strong> pour des messages plus riches&nbsp;:
                <code>vitl build -O0 -g -o build/app src/main.vitl</code>.
            </li>
            <li><strong>Inspection statique</strong> avec <code>vitl check src/</code> (style, imports, incohérences
                communes).</li>
            <li><strong>Lire/ajouter des types aux frontières</strong> (I/O, FFI, conversions) pour faire apparaître les
                incompatibilités.</li>
            <li><strong>Tracer</strong> ce qui se passe&nbsp;: ajouter <code>std.io::eprintln("dbg: ...")</code> ou
                <code>std.debug::dump("state=...")</code> si dispo.
            </li>
            <li><strong>Documenter le correctif</strong> dans le code (commentaire court) si l’origine était subtile
                (encodage, chemin relatif, etc.).</li>
        </ol>

        <div class="card">
            <strong>Raccourcis utiles</strong>
            <ul>
                <li><code>vitl check src/</code> → détecte tôt les erreurs courantes.</li>
                <li><code>vitl build -O0 -g ...</code> → backtrace et messages détaillés.</li>
                <li><code>--emit-ir</code> / <code>--emit-bytecode</code> → inspection avancée (comprendre ce que le
                    compilateur voit).</li>
                <li><code>vitl test</code> → verrouiller un correctif avec un test simple.</li>
            </ul>
        </div>

        <h3>13.2 Anatomie d’un message d’erreur</h3>
        <p>Un diagnostic VITL indique typiquement <em>où</em> (fichier:ligne:colonne), <em>quoi</em> (code, libellé) et
            <em>piste</em> (conseil). Exemple&nbsp;:
        </p>
        <pre><code>src/app/main.vitl:12:15: E0002: types incompatibles
  aide: caster avec `as` ou convertir avec `.to_string()` selon le contexte
</code></pre>
        <ul>
            <li><strong>Code</strong> (p.ex. E0002) → catégorie (typage, I/O, FFI…)</li>
            <li><strong>Libellé</strong> → nature précise (ex. «&nbsp;types incompatibles&nbsp;»)</li>
            <li><strong>Aide</strong> → action concrète (cast, import, check du chemin…)</li>
        </ul>

        <h3>13.3 Erreurs de compilation fréquentes (avec correctifs)</h3>

        <h4>E0001 — Symbole inconnu / import manquant</h4>
        <pre><code>// Mauvais
module app.main
fn main()-&gt;i32 {
  std.io::pritnln("hi")   // faute de frappe + pas d'import
  return 0
}

// Correct
module app.main
import std.io
fn main()-&gt;i32 {
  std.io::println("hi")
  return 0
}
</code></pre>
        <ul>
            <li>Vérifier l’<strong>orthographe</strong> et l’<strong>import</strong> (et l’ordre module → imports →
                code).
            </li>
            <li>Nom de module = <strong>chemin</strong> du fichier. Exemple&nbsp;: <code>src/util/str.vitl</code> ⇒
                <code>module util.str</code>.
            </li>
        </ul>

        <h4>E0002 — Types incompatibles (cast/convertir)</h4>
        <pre><code>// Mauvais
let n:i32 = 3
let x:f64 = 0.5
let y = n + x      // i32 + f64 → erreur

// Correct (cast local)
let n:i32 = 3
let x:f64 = 0.5
let y = (n as f64) + x

// Chaînes
std.io::println("n=" + n)              // E0002
std.io::println("n=" + n.to_string())  // OK
</code></pre>
        <p><strong>Règle</strong>&nbsp;: conversion explicite pour les nombres (<code>as</code>),
            <code>.to_string()</code> pour concaténer avec du texte.
        </p>

        <h4>E0003 — Variable non initialisée</h4>
        <pre><code>// Mauvais
let mut acc:i32
if cond { acc = 1 }
std.io::println(acc.to_string())

// Correct
let mut acc:i32 = 0
if cond { acc = 1 }
std.io::println(acc.to_string())
</code></pre>

        <h4>E0401 — <code>match</code> non exhaustif</h4>
        <pre><code>enum Mode { Fast, Slow }

match m {
  Mode::Fast =&gt; do_fast(),
  // manque Slow → E0401
}

// Correct
match m {
  Mode::Fast =&gt; do_fast(),
  Mode::Slow =&gt; do_slow(),
}
</code></pre>

        <h4>E0501 — Conflit de mutabilité</h4>
        <p>Déclarez <code>let mut</code> si vous modifiez une variable. Évitez les écritures concurrentes dans la même
            expression.</p>

        <h4>E0601 — Format chaîne invalide (p.ex. CString)</h4>
        <p>Pour le FFI, une <code>CString</code> ne doit pas contenir <code>\0</code> interne. Voir la section FFI
            ci-dessous.</p>

        <h3>13.4 Erreurs d’exécution fréquentes (runtime)</h3>

        <h4>E2001 — Fichier introuvable (I/O)</h4>
        <pre><code>let path = "data/config.txt"
if !std.fs::exists(path) {
  std.io::eprintln("E2001: fichier introuvable → " + path)
  return 3 // EX_IO
}
let txt = std.fs::read_to_string(path)?  // `?` propage l'erreur I/O
</code></pre>
        <ul>
            <li>Lancez depuis la <strong>racine</strong> du projet ou utilisez un <strong>chemin absolu</strong>.</li>
            <li>CI/CD&nbsp;: vérifiez que le fichier est <strong>copié</strong> dans l’arborescence d’exécution.</li>
        </ul>

        <h4>E0301 — Dépassement d’index</h4>
        <pre><code>let v:[i32] = [1,2,3]
let x = v[3]  // panique: hors bornes
// Correct
if i &lt; v.len() { let x = v[i] }
</code></pre>

        <h4>E0201 — Division par zéro</h4>
        <pre><code>fn div(a:i32, b:i32) -&gt; Result&lt;i32,str&gt; {
  if b == 0 { return Result::Err("division par zéro") }
  return Result::Ok(a / b)
}
</code></pre>

        <h4>E0801 — UTF-8 invalide</h4>
        <p>En lecture texte, fichiers mal encodés ⇒ préférer lecture binaire + conversion contrôlée ou nettoyer
            l’entrée.
        </p>

        <h3>13.5 FFI (C) — erreurs typiques et correctifs</h3>
        <div class="callout warn">
            <h4>Checklist sécurité FFI</h4>
            <ul>
                <li>Appels C dans <code>unsafe { ... }</code> uniquement.</li>
                <li>Chaînes&nbsp;: utiliser <code>std.c::CString::from_str</code> et conserver la durée de vie.</li>
                <li>Préciser <strong>qui alloue/libère</strong> (et avec quelle fonction) côté C.</li>
                <li>Passer <code>ptr+len</code> pour les buffers binaires, vérifier les bornes côté C.</li>
            </ul>
        </div>

        <h4>E1001 — Appel FFI hors <code>unsafe</code></h4>
        <pre><code>// Mauvais
extern "C" { fn puts(msg:*const char)-&gt;i32 }
fn main()-&gt;i32 {
  let s = std.c::CString::from_str("Hi\n")
  puts(s.unwrap().as_ptr()) // E1001
  return 0
}

// Correct
extern "C" { fn puts(msg:*const char)-&gt;i32 }
fn main()-&gt;i32 {
  let s = std.c::CString::from_str("Hi\n")?
  unsafe { _ = puts(s.as_ptr()) }
  return 0
}
</code></pre>

        <h4>E0601 — CString invalide (caractère nul)</h4>
        <pre><code>let msg = std.c::CString::from_str("ok\0oops") // E0601
if msg.is_err() { return Result::Err("E0601: CString invalide (\\0 interne)") }
</code></pre>

        <h4>E0701 — FFI: code de retour d’échec</h4>
        <pre><code>let rc = unsafe { foo_call(...) }
if rc != 0 {
  std.io::eprintln("E0701: FFI call failed (rc="+rc.to_string()+")")
  return 4 // EX_FFI
}
</code></pre>

        <h3>13.6 Quand « rien » ne marche : stratégie pas-à-pas</h3>
        <ol>
            <li><strong>Confirmez l’environnement</strong> (répertoire courant, OS, droits d’accès).</li>
            <li><strong>Affichez les arguments</strong> au démarrage (<code>std.cli::args()</code>) pour vérifier ce que
                reçoit votre programme.</li>
            <li><strong>Utilisez des chemins absolus</strong> pour les ressources (temporairement, pour lever le doute).
            </li>
            <li><strong>Ajoutez des logs</strong> ciblés (une ligne par étape importante, sur <code>stderr</code> si
                possible).</li>
            <li><strong>Réduisez</strong> à un MRE et remontez progressivement jusqu’à l’état initial.</li>
        </ol>

        <h3>13.7 Performance ou bug&nbsp;? (petits tests rapides)</h3>
        <pre><code>let t0 = std.time::now()
heavy()
std.io::eprintln("dbg: heavy ms=" + (std.time::now()-t0).to_string())
</code></pre>
        <ul>
            <li>Si le temps explose, suspectez une <strong>copie inutile</strong>, une <strong>lecture répétée</strong>
                de
                fichier, ou une <strong>boucle</strong> mal bornée.</li>
            <li>Pré-allouez avec <code>std.vec::with_capacity</code> si la taille est connue.</li>
        </ul>

        <h3>13.8 Gabarits de messages (prêts à coller)</h3>
        <div class="card">
            <ul>
                <li><strong>I/O manquant</strong>&nbsp;:
                    <code>E2001: fichier introuvable → &lt;chemin&gt;</code><br><em>Astuce&nbsp;:</em> «&nbsp;Lancez
                    depuis la
                    racine du projet ou passez un chemin absolu.&nbsp;»
                </li>
                <li><strong>Usage CLI</strong>&nbsp;: <code>usage: app &lt;fichier&gt; [options]</code> → retournez
                    <code>2</code>.
                </li>
                <li><strong>FFI échec</strong>&nbsp;: <code>E0701: FFI call failed (rc=&lt;code&gt;)</code> → retournez
                    <code>4</code>.
                </li>
                <li><strong>Type</strong>&nbsp;:
                    <code>E0002: types incompatibles (attendu &lt;T&gt;, reçu &lt;U&gt;)</code> +
                    piste cast.
                </li>
            </ul>
        </div>

        <h3>13.9 Par thèmes : checklists de résolution</h3>
        <details>
            <summary><strong>Arguments CLI</strong></summary>
            <ul>
                <li>Afficher <code>argv</code> pour vérifier l’ordre/présence.</li>
                <li>Codes de sortie&nbsp;: <code>2</code> pour «&nbsp;usage&nbsp;».</li>
            </ul>
        </details>
        <details>
            <summary><strong>Fichiers &amp; chemins</strong></summary>
            <ul>
                <li>Tester <code>std.fs::exists</code> avant lecture/écriture.</li>
                <li>Utiliser temporairement un chemin absolu pour lever le doute.</li>
                <li>Droits d’accès (permission refusée) → message clair + piste.</li>
            </ul>
        </details>
        <details>
            <summary><strong>Chaînes &amp; encodage</strong></summary>
            <ul>
                <li>UTF-8 strict en lecture texte ; si doute → lecture binaire puis conversion.</li>
                <li>Concaténation → <code>.to_string()</code> pour nombres.</li>
            </ul>
        </details>
        <details>
            <summary><strong>Typage</strong></summary>
            <ul>
                <li>Ajouter des types aux retours de fonctions publiques.</li>
                <li>Caster localement avec <code>as</code> pour les numériques.</li>
            </ul>
        </details>
        <details>
            <summary><strong>FFI</strong></summary>
            <ul>
                <li><code>unsafe</code> autour des appels, <code>CString</code> sans <code>\0</code> interne.</li>
                <li>Documenter la responsabilité d’allocation/libération.</li>
            </ul>
        </details>

        <h3>13.10 Tests de non-régression (verrouiller le fix)</h3>
        <pre><code>test "lecture fichier: path manquant renvoie EX_IO" {
  // pseudo-test: isolez la fonction qui résout un code depuis un message
  let rc = map_error_to_exit("E2001: fichier introuvable → data.txt")
  assert(rc == 3)
}
</code></pre>

        <h3>13.11 Exemples « messages enrichis »</h3>
        <pre><code>// I/O robuste
let path = argv[1]
if !std.fs::exists(path) {
  std.io::eprintln("E2001: fichier introuvable → " + path)
  std.io::eprintln("Astuce: lancer depuis la racine du projet ou passer un chemin absolu.")
  return 3
}
</code></pre>
        <pre><code>// FFI robuste
let msg = std.c::CString::from_str("ok\n")
if msg.is_err() { return Result::Err("E0601: CString invalide (caractère nul)") }
unsafe { _ = puts(msg.unwrap().as_ptr()) }
</code></pre>

        <h3>13.12 Mini-FAQ diagnostics</h3>
        <ul>
            <li><strong>Dois-je tout convertir en <code>String</code> ?</strong> Non. Convertissez <em>au moment</em>
                d’afficher/concaténer. Gardez des types numériques pour calculer.</li>
            <li><strong>Pourquoi un fichier introuvable en CI mais pas en local ?</strong> Chemin relatif et répertoire
                courant différents. Utilisez des chemins absolus ou synchronisez les dossiers dans votre pipeline.</li>
            <li><strong>Je n’ai pas de trace lors d’un échec.</strong> Recompilez avec <code>-g</code> et assurez-vous
                que
                l’échec est bien un <code>panic</code> ou qu’un message est émis sur <code>stderr</code>.</li>
        </ul>

        <p class="card"><strong>Résumé</strong> — Lisez le message complet · isolez un MRE · <code>vitl check</code> +
            <code>-O0 -g</code> · ajoutez des types aux frontières · messages enrichis et codes stables · verrouillez le
            fix
            par un test.
        </p>
    </section>

    <hr />

    <!-- 14) CHECKLIST -->
    <section id="checklist">
        <h2>14) Checklist avant de livrer</h2>

        <div class="callout info">
            <h4>Pourquoi cette checklist&nbsp;?</h4>
            <p>Elle rassemble tout ce qu’il faut vérifier avant d’expédier un binaire ou un script Vitte Light (VITL).
                Cochez de haut en bas&nbsp;: structure, build, qualité, erreurs, I/O, FFI, perfs, docs, packaging, CI/CD
                et
                post-livraison. <em>Astuce</em>&nbsp;: gardez un <strong>Mini Repro d’Erreur (MRE)</strong> pour chaque
                correction critique et un <strong>test</strong> associé.</p>
        </div>

        <h3>14.1 Contrôle express (60 s)</h3>
        <ul>
            <li>[ ] Le programme se lance par <code>vitl run</code> <em>et</em> le binaire par <code>./build/app</code>
                sans
                surprise.</li>
            <li>[ ] <code>vitl fmt</code> et <code>vitl check</code> ne signalent rien.</li>
            <li>[ ] <code>vitl test</code> passe localement.</li>
            <li>[ ] Codes de sortie documentés et respectés (0/1/2/3/4).</li>
            <li>[ ] README/usage minimal à jour.</li>
        </ul>

        <h3>14.2 Structure &amp; modules</h3>
        <ul>
            <li>[ ] Dossiers séparés&nbsp;: <code>/src</code> (VITL), <code>/libs</code> (C/FFI), <code>/build</code>
                (artefacts), <code>/tests</code> (si besoin).</li>
            <li>[ ] Un fichier = un module. Nom de module = chemin disque (ex. <code>src/util/str.vitl</code> →
                <code>module util.str</code>).
            </li>
            <li>[ ] Fichiers d’entrée <code>main.vitl</code> ou <code>app/main.vitl</code> clairement identifiés.</li>
            <li>[ ] Imports triés par hiérarchie, sans doublons ni imports morts.</li>
        </ul>

        <h3>14.3 Build &amp; artefacts</h3>
        <ul>
            <li>[ ] Débogage&nbsp;: <code>vitl build -O0 -g -o build/app src/main.vitl</code> OK.</li>
            <li>[ ] Release&nbsp;: <code>vitl build -O3 -o build/app src/main.vitl</code> OK (ou <code>-O2</code> selon
                politique).</li>
            <li>[ ] Artefacts attendus présents (<code>build/app</code>, docs, éventuel <code>.vitbc</code>).</li>
            <li>[ ] (Optionnel) <code>--emit-ir</code> / <code>--emit-bytecode</code> génèrent des sorties exploitables.
            </li>
        </ul>

        <h3>14.4 Qualité du code &amp; style</h3>
        <ul>
            <li>[ ] <code>vitl fmt</code> appliqué à <code>src/</code> et <code>tests/</code>.</li>
            <li>[ ] <code>vitl check</code> sans avertissement bloquant (imports morts, types flous, variables
                inutilisées).
            </li>
            <li>[ ] Noms explicites (<code>snake_case</code> pour variables/fonctions, <code>CamelCase</code> pour
                types).
            </li>
            <li>[ ] Types explicites aux frontières (I/O, FFI, API publique).</li>
        </ul>

        <h3>14.5 Gestion des erreurs &amp; UX</h3>
        <ul>
            <li>[ ] API système → <code>Result&lt;T,E&gt;</code> + propagation <code>?</code> ; pas de
                <code>panic()</code>
                hors cas irrécupérables.
            </li>
            <li>[ ] Codes de sortie stables&nbsp;: <strong>0</strong> succès · <strong>1</strong> panic/générique ·
                <strong>2</strong> usage CLI · <strong>3</strong> I/O · <strong>4</strong> FFI.
            </li>
            <li>[ ] Messages «&nbsp;enrichis&nbsp;» sur <code>stderr</code> (conseil d’usage, chemin, cause).</li>
            <li>[ ] <code>--help</code> clair si CLI&nbsp;: usage, options, exemples, codes de sortie.</li>
        </ul>

        <h3>14.6 Entrées/Sorties &amp; fichiers</h3>
        <ul>
            <li>[ ] Chemins relatifs vs absolus maîtrisés ; si ressources, test de présence via
                <code>std.fs::exists</code>.
            </li>
            <li>[ ] Lecture texte → UTF-8 attendu (si doute, lecture binaire + conversion contrôlée).</li>
            <li>[ ] Écritures atomiques si nécessaire (temp + rename) pour éviter la corruption.</li>
            <li>[ ] Gestion des grosses tailles (streaming au lieu de tout en mémoire, si pertinent).</li>
        </ul>

        <h3>14.7 Mémoire &amp; sécurité</h3>
        <ul>
            <li>[ ] Usage de <code>Rc/Weak</code> compris ; pas de cycles forts non désirés.</li>
            <li>[ ] Pas d’<code>unsafe</code> hors FFI ; pas de pointeur C stocké vers une <code>String</code>
                temporaire.
            </li>
            <li>[ ] Accès indexés protégés (limites vérifiées, <code>get()</code> si nécessaire).</li>
        </ul>

        <h3>14.8 FFI (C) — si utilisé</h3>
        <ul>
            <li>[ ] Déclarations <code>extern "C"</code> correctes (types stables&nbsp;: <code>int32_t</code>,
                <code>size_t</code>…).
            </li>
            <li>[ ] Appels C dans <code>unsafe { ... }</code> uniquement.</li>
            <li>[ ] Chaînes&nbsp;: <code>std.c::CString::from_str</code> (sans <code>\0</code> interne), durée de vie
                respectée.</li>
            <li>[ ] Ownership documenté (qui alloue/libère, et comment).</li>
            <li>[ ] Codes de retour C testés&nbsp;: non-zéro ⇒ message + sortie <strong>4</strong>.</li>
            <li>[ ] Lien/bibliothèques&nbsp;: <code>-L</code>, <code>-l</code>, rpath et variantes (statique/dynamique)
                validés.</li>
        </ul>

        <h3>14.9 Tests &amp; couverture</h3>
        <ul>
            <li>[ ] <code>vitl test</code> passe en local et en CI.</li>
            <li>[ ] Au moins un test d’erreur (usage CLI, fichier manquant, FFI erreur).</li>
            <li>[ ] Un test rapide «&nbsp;fumée&nbsp;» (smoke) qui lance le binaire avec un cas trivial.</li>
        </ul>

        <h3>14.10 Performance &amp; ressources</h3>
        <ul>
            <li>[ ] Chemins chauds sans copies inutiles (ex. <code>vec::with_capacity</code> si taille connue).</li>
            <li>[ ] Mesure simple (<code>std.time::now()</code>) ajoutée/validée pour opérations lourdes, retirée ou
                passée
                en mode <code>--verbose</code>.</li>
        </ul>

        <h3>14.11 Documentation &amp; exemples</h3>
        <ul>
            <li>[ ] Sections de doc <code>///</code> pour les fonctions publiques (but, paramètres, erreurs, exemple
                minimal).</li>
            <li>[ ] <code>vitl doc</code> génère une sortie propre (si configuré).</li>
            <li>[ ] README&nbsp;: comment exécuter, compiler, tester, codes de sortie, exemple
                «&nbsp;copier-coller&nbsp;».
            </li>
            <li>[ ] CHANGELOG/notes de version (si applicable).</li>
        </ul>

        <h3>14.12 Packaging &amp; distribution</h3>
        <ul>
            <li>[ ] Binaire release reproduisible (mêmes options), nommage clair
                (<code>app-&lt;os&gt;-&lt;arch&gt;</code>
                si multiplateforme).</li>
            <li>[ ] Licence incluse si redistribution.</li>
            <li>[ ] (Optionnel) Somme de contrôle (SHA256) et signature.</li>
            <li>[ ] Archive propre (pas de fichiers temporaires ni artefacts de debug).</li>
        </ul>

        <h3>14.13 CI/CD</h3>
        <ul>
            <li>[ ] Pipeline&nbsp;: fmt → check → build (debug) → test → build (release) → (doc) → package → publier
                artefacts.</li>
            <li>[ ] Variables d’environnement et chemins validés (exécution depuis la racine repo).</li>
            <li>[ ] Tests rapides pour ne pas bloquer les PRs (stratégie «&nbsp;rapide par défaut&nbsp;» + jobs lourds
                en
                nightly si besoin).</li>
        </ul>

        <h3>14.14 Observabilité &amp; journalisation</h3>
        <ul>
            <li>[ ] Logs d’erreur sur <code>stderr</code>, messages concis, pas de secrets en clair.</li>
            <li>[ ] Niveau de verbosité contrôlable (<code>-v</code>/<code>--verbose</code>), silencieux par défaut.
            </li>
        </ul>

        <h3>14.15 Post-livraison (dernier mètre)</h3>
        <ul>
            <li>[ ] <strong>Smoke test</strong> exécuté sur l’artefact final (même archive que l’utilisateur).</li>
            <li>[ ] Plan de rollback si blocant.</li>
            <li>[ ] Ticket(s) ou notes de suivi ouverts pour dettes techniques restantes.</li>
        </ul>

        <div class="card">
            <strong>Rappels « prêt à coller »</strong>
            <pre><code># Formatage, lint, build, tests (local)
vitl fmt src/ tests/
vitl check src/
vitl build -O0 -g -o build/app src/main.vitl
vitl test
vitl build -O3 -o build/app src/main.vitl

# Exécution simple
./build/app --help
./build/app &lt;args&gt;</code></pre>
        </div>

        <p class="note">FIN DU GUIDE</p>
    </section>

    </main>

    <!-- Script externe -->
    <script src="./js/script.js"></script>


</body>

</html>
